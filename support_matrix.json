{
  "version": 2,
  "generated_at_utc": "2026-02-18T04:49:26Z",
  "library": "/data/tmp/cargo-target/release/libfrankenlibc_abi.so",
  "total_exported": 929,
  "taxonomy": {
    "Implemented": "Native Rust code owns the entire operation. No host libc dependency. Full test coverage required.",
    "RawSyscall": "ABI entrypoint marshals arguments directly to Linux syscall instruction. No glibc call-through.",
    "GlibcCallThrough": "Delegates to host glibc after membrane pre/post validation. Requires host libc at runtime.",
    "Stub": "Deterministic failure contract. Returns stable errno/error code. Documented in support policy.",
    "perf_classes": {
      "strict_hotpath": "Called >= 1M/sec in typical workloads. Must meet <20ns strict budget.",
      "hardened_hotpath": "Called >= 1M/sec in hardened mode. Must meet <200ns hardened budget.",
      "coldpath": "Called < 1K/sec. No latency budget enforced."
    },
    "default_policy": "Any exported symbol absent from explicit classification defaults to Stub and causes drift failure (exit 3).",
    "mode_contract": {
      "strict": "POSIX-correct error semantics. Membrane validates but never silently rewrites. ABI-compatible.",
      "hardened": "TSM repair enabled. Membrane applies deterministic healing (clamp, truncate, safe-default). Logs HealingAction."
    },
    "artifact_applicability": {
      "Interpose": [
        "Implemented",
        "RawSyscall",
        "GlibcCallThrough",
        "Stub"
      ],
      "Replace": [
        "Implemented",
        "RawSyscall"
      ],
      "rule": "Implemented+RawSyscall apply to both artifacts; GlibcCallThrough+Stub are Interpose-only."
    }
  },
  "symbols": [
    {
      "symbol": "__errno_location",
      "status": "Implemented",
      "module": "errno_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Thread-local errno via Rust; ABI-compatible __errno_location pointer",
      "hardened_semantics": "Thread-local errno; no mode difference (stateless query)",
      "default_stub": false
    },
    {
      "symbol": "__frankenlibc_startup_phase0",
      "status": "Implemented",
      "module": "startup_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Phase-0 startup skeleton for controlled fixtures; validates argc/argv/envp and captures auxv/secure-mode invariants",
      "hardened_semantics": "Phase-0 startup with hardened membrane routing; deterministic startup invariant capture for fixture binaries",
      "default_stub": false
    },
    {
      "symbol": "__frankenlibc_startup_snapshot",
      "status": "Implemented",
      "module": "startup_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Phase-0 startup skeleton for controlled fixtures; validates argc/argv/envp and captures auxv/secure-mode invariants",
      "hardened_semantics": "Phase-0 startup with hardened membrane routing; deterministic startup invariant capture for fixture binaries",
      "default_stub": false
    },
    {
      "symbol": "__libc_start_main",
      "status": "Implemented",
      "module": "startup_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Phase-0 startup skeleton for controlled fixtures; validates argc/argv/envp and captures auxv/secure-mode invariants",
      "hardened_semantics": "Phase-0 startup with hardened membrane routing; deterministic startup invariant capture for fixture binaries",
      "default_stub": false
    },
    {
      "symbol": "_exit",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for process control; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates argv/envp pointer arrays before execve",
      "default_stub": false
    },
    {
      "symbol": "_longjmp",
      "status": "Implemented",
      "module": "setjmp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Alias for longjmp.",
      "hardened_semantics": "Same.",
      "default_stub": "Aborts"
    },
    {
      "symbol": "_setjmp",
      "status": "Implemented",
      "module": "setjmp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Alias for setjmp (no signal mask save).",
      "hardened_semantics": "Same.",
      "default_stub": "Returns -1"
    },
    {
      "symbol": "abs",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Integer absolute value via wrapping_abs",
      "hardened_semantics": "No mode difference; pure computation",
      "default_stub": false
    },
    {
      "symbol": "accept",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "accept4",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; accept with flags (SOCK_NONBLOCK, SOCK_CLOEXEC); POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates fd and flag arguments",
      "default_stub": false
    },
    {
      "symbol": "access",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "acos",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; finite |x|>1 sets errno=EDOM and preserves IEEE 754 NaN/Inf behavior",
      "hardened_semantics": "Same domain errno signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "acosf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "acosh",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; finite x<1 sets errno=EDOM and preserves IEEE 754 NaN/Inf behavior",
      "hardened_semantics": "Same domain errno signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "acoshf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "aio_cancel",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "syscall"
    },
    {
      "symbol": "aio_error",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "aio_fsync",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "syscall"
    },
    {
      "symbol": "aio_read",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "syscall"
    },
    {
      "symbol": "aio_return",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "aio_suspend",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "syscall"
    },
    {
      "symbol": "aio_write",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "syscall"
    },
    {
      "symbol": "alarm",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "aligned_alloc",
      "status": "Implemented",
      "module": "malloc_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust arena allocator; null on failure; double-free silently ignored",
      "hardened_semantics": "Arena with healing: foreign-ptr realloc as malloc, double-free logged as HealingAction",
      "default_stub": false
    },
    {
      "symbol": "alphasort",
      "status": "Implemented",
      "module": "dirent_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc alphasort",
      "hardened_semantics": "Passthrough to glibc alphasort",
      "default_stub": false
    },
    {
      "symbol": "arc4random",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "arc4random via SYS_getrandom",
      "hardened_semantics": "arc4random via SYS_getrandom",
      "default_stub": false
    },
    {
      "symbol": "arc4random_buf",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "arc4random_buf via SYS_getrandom",
      "hardened_semantics": "arc4random_buf via SYS_getrandom",
      "default_stub": false
    },
    {
      "symbol": "arc4random_uniform",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "arc4random_uniform via rejection sampling + SYS_getrandom",
      "hardened_semantics": "arc4random_uniform via rejection sampling + SYS_getrandom",
      "default_stub": false
    },
    {
      "symbol": "asctime",
      "status": "Implemented",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Thread-local buffer wrapping asctime_r. Returns pointer to static string.",
      "hardened_semantics": "Same. Null pointer returns NULL.",
      "default_stub": "Returns NULL"
    },
    {
      "symbol": "asctime_r",
      "status": "Implemented",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure Rust formatting of broken-down time to string; no syscall",
      "hardened_semantics": "Pure Rust formatting with null pointer guard",
      "default_stub": false
    },
    {
      "symbol": "asin",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; finite |x|>1 sets errno=EDOM and preserves IEEE 754 NaN/Inf behavior",
      "hardened_semantics": "Same domain errno signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "asinf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "asinh",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; odd inverse-hyperbolic function over finite domain; no errno side effects",
      "hardened_semantics": "Rust std::f64 math; no mode difference expected for finite inputs",
      "default_stub": false
    },
    {
      "symbol": "asinhf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "asprintf",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native formatted allocation using frankenlibc printf renderer and malloc-compatible output contract",
      "hardened_semantics": "Native formatted allocation with runtime-policy mediation; denial/alloc-failure returns deterministic error",
      "default_stub": false
    },
    {
      "symbol": "atan",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "atan2",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "atan2f",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "atanf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "atanh",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; finite |x|>1 sets errno=EDOM and |x|==1 sets errno=ERANGE with IEEE 754 outputs preserved",
      "hardened_semantics": "Same errno domain/range signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "atanhf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "atexit",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "atof",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "String-to-double conversion via Rust parse; POSIX-correct",
      "hardened_semantics": "Membrane-validated string scan before parse",
      "default_stub": false
    },
    {
      "symbol": "atoi",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "atol",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "atoll",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "basename",
      "header": "libgen.h",
      "family": "unistd",
      "status": "Implemented",
      "notes": "Extract filename from path"
    },
    {
      "symbol": "bcmp",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust byte comparison; returns 0 or 1",
      "hardened_semantics": "Clamps length to tracked allocation bounds",
      "default_stub": false
    },
    {
      "symbol": "bcopy",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Delegates to memmove with swapped argument order",
      "hardened_semantics": "Same as memmove hardened semantics",
      "default_stub": false
    },
    {
      "symbol": "bind",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "bindtextdomain",
      "status": "Implemented",
      "module": "locale_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc bindtextdomain",
      "hardened_semantics": "Passthrough to glibc bindtextdomain",
      "default_stub": false
    },
    {
      "symbol": "bsearch",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "btowc",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "ASCII-only single-byte to wide-char conversion (UTF-8 locale contract); EOF maps to WEOF",
      "hardened_semantics": "Same conversion semantics with membrane-gated deny/repair paths for invalid ranges",
      "default_stub": false
    },
    {
      "symbol": "bzero",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust zeroing with black_box anti-optimization; no repair",
      "hardened_semantics": "Clamps length to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "calloc",
      "status": "Implemented",
      "module": "malloc_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust arena allocator; null on failure; double-free silently ignored",
      "hardened_semantics": "Arena with healing: foreign-ptr realloc as malloc, double-free logged as HealingAction",
      "default_stub": false
    },
    {
      "symbol": "cbrt",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; odd real-root function over all finite inputs, preserving signed zero and IEEE 754 NaN/Inf behavior",
      "hardened_semantics": "Rust libm path; no mode difference expected for finite inputs",
      "default_stub": false
    },
    {
      "symbol": "cbrtf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "ceil",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "ceilf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "cfgetispeed",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "cfgetospeed",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "cfsetispeed",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "cfsetospeed",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "chdir",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "chmod",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "chown",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "clearenv",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "fast",
      "strict_semantics": "Native environment clear via HOST_ENVIRON snapshot + unsetenv loop",
      "hardened_semantics": "Same clear contract with runtime-policy deny/observe path",
      "default_stub": false
    },
    {
      "symbol": "clearerr",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "clock",
      "status": "RawSyscall",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for time queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; defaults invalid clock_id to CLOCK_REALTIME",
      "default_stub": false
    },
    {
      "symbol": "clock_getres",
      "status": "RawSyscall",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_clock_getres; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates clock_id before calling kernel",
      "default_stub": false
    },
    {
      "symbol": "clock_gettime",
      "status": "RawSyscall",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for time queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; defaults invalid clock_id to CLOCK_REALTIME",
      "default_stub": false
    },
    {
      "symbol": "clock_nanosleep",
      "status": "RawSyscall",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_clock_nanosleep; returns error code directly",
      "hardened_semantics": "Raw syscall; validates clock_id and req pointer",
      "default_stub": false
    },
    {
      "symbol": "clock_settime",
      "status": "RawSyscall",
      "module": "time_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_clock_settime \u2014 set clock",
      "hardened_semantics": "SYS_clock_settime \u2014 set clock",
      "default_stub": false
    },
    {
      "symbol": "close",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "close_range",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_close_range \u2014 close fd range",
      "hardened_semantics": "SYS_close_range \u2014 close fd range",
      "default_stub": false
    },
    {
      "symbol": "closedir",
      "status": "RawSyscall",
      "module": "dirent_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for directory enumeration; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates path pointer bounds before getdents64",
      "default_stub": false
    },
    {
      "symbol": "closelog",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc closelog",
      "hardened_semantics": "Passthrough to glibc closelog",
      "default_stub": false
    },
    {
      "symbol": "confstr",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native confstr for supported names (currently _CS_PATH) with POSIX copy/length behavior and errno contract",
      "hardened_semantics": "Same semantics with runtime-policy deny handling and deterministic EPERM failure path",
      "default_stub": false
    },
    {
      "symbol": "connect",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "copy_file_range",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_copy_file_range \u2014 server-side file copy",
      "hardened_semantics": "SYS_copy_file_range \u2014 server-side file copy",
      "default_stub": false
    },
    {
      "symbol": "copysign",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; magnitude/sign transfer preserves IEEE 754 NaN payload and signed zero semantics with no errno side effects",
      "hardened_semantics": "Rust libm path; no mode difference expected for finite inputs",
      "default_stub": false
    },
    {
      "symbol": "copysignf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "cos",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "cosf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "cosh",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; finite overflow to infinity sets errno=ERANGE while preserving IEEE 754 behavior",
      "hardened_semantics": "Same ERANGE overflow signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "coshf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "creat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "creat64",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "LP64 alias to native unistd/io/mmap entrypoints (no glibc call-through)",
      "hardened_semantics": "Same alias routing with membrane behavior inherited from target entrypoints",
      "default_stub": false
    },
    {
      "symbol": "crypt",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc crypt",
      "hardened_semantics": "Passthrough to glibc crypt",
      "default_stub": false
    },
    {
      "symbol": "ctermid",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "fast",
      "strict_semantics": "Native constant-path implementation returning /dev/tty",
      "hardened_semantics": "Same constant-path implementation; no mode divergence",
      "default_stub": false
    },
    {
      "symbol": "ctime",
      "status": "Implemented",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Thread-local buffer wrapping ctime_r. Returns pointer to static string.",
      "hardened_semantics": "Same. Null pointer returns NULL.",
      "default_stub": "Returns NULL"
    },
    {
      "symbol": "ctime_r",
      "status": "Implemented",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Combines epoch_to_broken_down with format_asctime; pure Rust",
      "hardened_semantics": "Pure Rust conversion with null pointer guard",
      "default_stub": false
    },
    {
      "symbol": "daemon",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Native fork+setsid+chdir+dup2 via raw syscalls",
      "hardened_semantics": "Native fork+setsid+chdir+dup2 via raw syscalls",
      "default_stub": false
    },
    {
      "symbol": "dgettext",
      "status": "Implemented",
      "module": "locale_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc dgettext",
      "hardened_semantics": "Passthrough to glibc dgettext",
      "default_stub": false
    },
    {
      "symbol": "difftime",
      "status": "Implemented",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure computation returning time1 - time0 as f64; no syscall",
      "hardened_semantics": "Pure computation; no mode difference",
      "default_stub": false
    },
    {
      "symbol": "dirname",
      "header": "libgen.h",
      "family": "unistd",
      "status": "Implemented",
      "notes": "Extract directory from path"
    },
    {
      "symbol": "div",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Integer division returning quotient and remainder; zero-denom returns zero",
      "hardened_semantics": "No mode difference; pure computation",
      "default_stub": false
    },
    {
      "symbol": "dl_iterate_phdr",
      "status": "GlibcCallThrough",
      "module": "dlfcn_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc dl_iterate_phdr",
      "hardened_semantics": "Passthrough to glibc dl_iterate_phdr",
      "default_stub": false
    },
    {
      "symbol": "dladdr",
      "status": "GlibcCallThrough",
      "module": "dlfcn_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc dladdr",
      "hardened_semantics": "Passthrough to glibc dladdr",
      "default_stub": false
    },
    {
      "symbol": "dlclose",
      "status": "GlibcCallThrough",
      "module": "dlfcn_abi",
      "perf_class": "coldpath",
      "strict_semantics": "dlfcn boundary policy: host glibc call-through for dlopen/dlsym/dlclose with thread-local dlerror contract",
      "hardened_semantics": "dlfcn boundary policy: invalid dlopen flags heal to RTLD_NOW; null/denied loader inputs return deterministic dlerror",
      "default_stub": false
    },
    {
      "symbol": "dlerror",
      "status": "GlibcCallThrough",
      "module": "dlfcn_abi",
      "perf_class": "coldpath",
      "strict_semantics": "dlfcn boundary policy: host glibc call-through for dlopen/dlsym/dlclose with thread-local dlerror contract",
      "hardened_semantics": "dlfcn boundary policy: invalid dlopen flags heal to RTLD_NOW; null/denied loader inputs return deterministic dlerror",
      "default_stub": false
    },
    {
      "symbol": "dlopen",
      "status": "GlibcCallThrough",
      "module": "dlfcn_abi",
      "perf_class": "coldpath",
      "strict_semantics": "dlfcn boundary policy: host glibc call-through for dlopen/dlsym/dlclose with thread-local dlerror contract",
      "hardened_semantics": "dlfcn boundary policy: invalid dlopen flags heal to RTLD_NOW; null/denied loader inputs return deterministic dlerror",
      "default_stub": false
    },
    {
      "symbol": "dlsym",
      "status": "GlibcCallThrough",
      "module": "dlfcn_abi",
      "perf_class": "coldpath",
      "strict_semantics": "dlfcn boundary policy: host glibc call-through for dlopen/dlsym/dlclose with thread-local dlerror contract",
      "hardened_semantics": "dlfcn boundary policy: invalid dlopen flags heal to RTLD_NOW; null/denied loader inputs return deterministic dlerror",
      "default_stub": false
    },
    {
      "symbol": "dprintf",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native formatted write to provided fd using frankenlibc printf renderer with POSIX return-length contract",
      "hardened_semantics": "Native formatted fd write with runtime-policy mediation; denied or short writes return deterministic failure",
      "default_stub": false
    },
    {
      "symbol": "dup",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for dup/dup2/pipe/fcntl; POSIX errno on failure",
      "hardened_semantics": "Raw syscall with hardened membrane; repair on invalid flags",
      "default_stub": false
    },
    {
      "symbol": "dup2",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for dup/dup2/pipe/fcntl; POSIX errno on failure",
      "hardened_semantics": "Raw syscall with hardened membrane; repair on invalid flags",
      "default_stub": false
    },
    {
      "symbol": "dup3",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "endgrent",
      "status": "Implemented",
      "module": "grp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: closes /etc/group enumeration and frees cached data",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "endmntent",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "endpwent",
      "status": "Implemented",
      "module": "pwd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: closes /etc/passwd enumeration and frees cached data",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "endutent",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "epoll_create",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "epoll_create1",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "epoll_ctl",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "epoll_pwait",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "epoll_wait",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "erf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "erfc",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "erfcf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "erff",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "ether_aton",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "fast",
      "strict_semantics": "Parses colon-delimited MAC string into six-byte static ether_addr storage and returns null on invalid syntax",
      "hardened_semantics": "Same parser path with deterministic null return for invalid/null inputs",
      "default_stub": false
    },
    {
      "symbol": "ether_aton_r",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "fast",
      "strict_semantics": "Parses colon-delimited MAC string into caller-provided ether_addr output and returns null on invalid syntax",
      "hardened_semantics": "Same parser path with deterministic null return for invalid/null inputs",
      "default_stub": false
    },
    {
      "symbol": "ether_ntoa",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "fast",
      "strict_semantics": "Formats six-byte ether_addr into lowercase colon-delimited static buffer string",
      "hardened_semantics": "Same formatter path with deterministic null return for null input",
      "default_stub": false
    },
    {
      "symbol": "ether_ntoa_r",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "fast",
      "strict_semantics": "Formats six-byte ether_addr into caller-provided lowercase colon-delimited buffer string",
      "hardened_semantics": "Same formatter path with deterministic null return for null input/output pointers",
      "default_stub": false
    },
    {
      "symbol": "eventfd",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "eventfd_read",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "eventfd_write",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "execl",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "syscall"
    },
    {
      "symbol": "execle",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "syscall"
    },
    {
      "symbol": "execlp",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "syscall"
    },
    {
      "symbol": "execve",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for process control; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates argv/envp pointer arrays before execve",
      "default_stub": false
    },
    {
      "symbol": "execvp",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for process control; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates argv/envp pointer arrays before execve",
      "default_stub": false
    },
    {
      "symbol": "execvpe",
      "status": "Implemented",
      "module": "process_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc execvpe",
      "hardened_semantics": "Passthrough to glibc execvpe",
      "default_stub": false
    },
    {
      "symbol": "exit",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "exp",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; finite overflow/underflow routes set errno=ERANGE while preserving IEEE 754 infinities/zeros",
      "hardened_semantics": "Same ERANGE signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "exp2",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; finite overflow/underflow routes set errno=ERANGE while preserving IEEE 754 infinities/zeros",
      "hardened_semantics": "Same ERANGE signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "exp2f",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "expf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "explicit_bzero",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Delegates to bzero with black_box guarantee",
      "hardened_semantics": "Same as bzero hardened semantics",
      "default_stub": false
    },
    {
      "symbol": "expm1",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; finite overflow to infinity sets errno=ERANGE while preserving precise near-zero behavior",
      "hardened_semantics": "Same ERANGE overflow signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "expm1f",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "fabs",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "fabsf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "faccessat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "fallocate",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_fallocate \u2014 allocate/deallocate file space",
      "hardened_semantics": "SYS_fallocate \u2014 allocate/deallocate file space",
      "default_stub": false
    },
    {
      "symbol": "fchdir",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "fchmod",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "fchmodat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "fchown",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "fchownat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "fclose",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "fcntl",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for dup/dup2/pipe/fcntl; POSIX errno on failure",
      "hardened_semantics": "Raw syscall with hardened membrane; repair on invalid flags",
      "default_stub": false
    },
    {
      "symbol": "fdatasync",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "fdim",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "fdimf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "fdopen",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "strict_fast",
      "strict_semantics": "Associate a FILE stream with an existing fd; mode validation",
      "hardened_semantics": "Same as strict; invalid mode returns NULL",
      "default_stub": false
    },
    {
      "symbol": "feof",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "ferror",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "fflush",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "ffs",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Find first set bit via trailing_zeros; returns 0 for input 0",
      "hardened_semantics": "No mode difference; pure computation",
      "default_stub": false
    },
    {
      "symbol": "ffsl",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Find first set bit in long via trailing_zeros",
      "hardened_semantics": "No mode difference; pure computation",
      "default_stub": false
    },
    {
      "symbol": "ffsll",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Find first set bit in long long via trailing_zeros",
      "hardened_semantics": "No mode difference; pure computation",
      "default_stub": false
    },
    {
      "symbol": "fgetc",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "fgetc_unlocked",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "fgetgrent",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "fgetpos",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "strict_fast",
      "strict_semantics": "Store current stream position into fpos_t",
      "hardened_semantics": "Same as strict with null-pointer validation",
      "default_stub": false
    },
    {
      "symbol": "fgetpos64",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "default",
      "strict_semantics": "LP64 alias to native fgetpos implementation",
      "hardened_semantics": "LP64 alias to native fgetpos implementation",
      "default_stub": false
    },
    {
      "symbol": "fgetpwent",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "fgets",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "fgetwc",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "fast",
      "strict_semantics": "Native UTF-8 stream decode over stdio registry-backed fgetc path",
      "hardened_semantics": "Same decode path with deterministic EILSEQ/WEOF handling and pushback rollback on partial invalid sequences"
    },
    {
      "symbol": "fgetws",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "fast",
      "strict_semantics": "Native wide-line read built on fgetwc with newline/length stop contract",
      "hardened_semantics": "Same bounded read contract with deterministic null-pointer and EOF behavior"
    },
    {
      "symbol": "fgetxattr",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_fgetxattr",
      "hardened_semantics": "SYS_fgetxattr",
      "default_stub": false
    },
    {
      "symbol": "fileno",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "flistxattr",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_flistxattr",
      "hardened_semantics": "SYS_flistxattr",
      "default_stub": false
    },
    {
      "symbol": "flock",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "BSD"
    },
    {
      "symbol": "flockfile",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "floor",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "floorf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "fma",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "fmaf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "fmax",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "fmaxf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "fmemopen",
      "status": "GlibcCallThrough",
      "module": "stdio_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "fmin",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "fminf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "fmod",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; y==0 or infinite x with finite y sets errno=EDOM while preserving IEEE 754 NaN behavior",
      "hardened_semantics": "Same errno signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "fmodf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "fnmatch",
      "status": "GlibcCallThrough",
      "module": "string_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc fnmatch",
      "hardened_semantics": "Passthrough to glibc fnmatch",
      "default_stub": false
    },
    {
      "symbol": "fopen",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "fopen64",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "default",
      "strict_semantics": "LP64 alias to native fopen implementation",
      "hardened_semantics": "LP64 alias to native fopen implementation",
      "default_stub": false
    },
    {
      "symbol": "fopencookie",
      "status": "GlibcCallThrough",
      "module": "stdio_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "fork",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for process control; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates argv/envp pointer arrays before execve",
      "default_stub": false
    },
    {
      "symbol": "forkpty",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc forkpty",
      "hardened_semantics": "Passthrough to glibc forkpty",
      "default_stub": false
    },
    {
      "symbol": "fpathconf",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native fd-validated pathconf value table; EBADF/EINVAL contract preserved",
      "hardened_semantics": "Same value table with runtime-policy deny handling and deterministic EPERM failure path",
      "default_stub": false
    },
    {
      "symbol": "fprintf",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native printf engine + stream-registry stdio path; no host glibc call-through",
      "hardened_semantics": "Native printf engine + stream-registry stdio with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "fputc",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "fputc_unlocked",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "fputs",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "fputwc",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "fast",
      "strict_semantics": "Native UTF-8 stream encode over stdio registry-backed fputc path",
      "hardened_semantics": "Same encode path with deterministic EILSEQ/WEOF behavior on invalid code points"
    },
    {
      "symbol": "fputws",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "fast",
      "strict_semantics": "Native wide-string write built on fputwc",
      "hardened_semantics": "Same bounded write contract with deterministic WEOF on write failures"
    },
    {
      "symbol": "fread",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "free",
      "status": "Implemented",
      "module": "malloc_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust arena allocator; null on failure; double-free silently ignored",
      "hardened_semantics": "Arena with healing: foreign-ptr realloc as malloc, double-free logged as HealingAction",
      "default_stub": false
    },
    {
      "symbol": "freeaddrinfo",
      "status": "Implemented",
      "module": "resolv_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Bootstrap resolver implementation: numeric getaddrinfo/getnameinfo + gai_strerror/freeaddrinfo with deterministic EAI_* failures",
      "hardened_semantics": "Resolver with deterministic repairs: invalid host/service normalized to safe defaults, evidence emitted",
      "default_stub": false
    },
    {
      "symbol": "freeifaddrs",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "fremovexattr",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_fremovexattr",
      "hardened_semantics": "SYS_fremovexattr",
      "default_stub": false
    },
    {
      "symbol": "freopen",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "strict_slow",
      "strict_semantics": "Close stream and reopen with new file/mode",
      "hardened_semantics": "Same as strict; flushes pending writes before close",
      "default_stub": false
    },
    {
      "symbol": "freopen64",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "default",
      "strict_semantics": "LP64 alias to native freopen implementation",
      "hardened_semantics": "LP64 alias to native freopen implementation",
      "default_stub": false
    },
    {
      "symbol": "frexp",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "frexpf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "fscanf",
      "status": "GlibcCallThrough",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to glibc vfscanf after membrane validation.",
      "hardened_semantics": "Same delegation; format string validated by glibc.",
      "default_stub": "Returns EOF"
    },
    {
      "symbol": "fseek",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream registry with SYS_lseek syscall; flushes pending writes, discards read buffer, updates logical offset",
      "hardened_semantics": "Native implementation; membrane validates stream ID, sets EINVAL on invalid whence; heals invalid offsets via safe default",
      "default_stub": false
    },
    {
      "symbol": "fseeko",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Aliases fseek on LP64 (off_t == long).",
      "hardened_semantics": "Same.",
      "default_stub": "Returns -1"
    },
    {
      "symbol": "fseeko64",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "default",
      "strict_semantics": "LP64 alias to native fseeko implementation",
      "hardened_semantics": "LP64 alias to native fseeko implementation",
      "default_stub": false
    },
    {
      "symbol": "fsetpos",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "strict_fast",
      "strict_semantics": "Restore stream position from fpos_t (delegates to fseek)",
      "hardened_semantics": "Same as strict with null-pointer validation",
      "default_stub": false
    },
    {
      "symbol": "fsetpos64",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "default",
      "strict_semantics": "LP64 alias to native fsetpos implementation",
      "hardened_semantics": "LP64 alias to native fsetpos implementation",
      "default_stub": false
    },
    {
      "symbol": "fsetxattr",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_fsetxattr",
      "hardened_semantics": "SYS_fsetxattr",
      "default_stub": false
    },
    {
      "symbol": "fstat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "fstat64",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "LP64 alias to native unistd/io/mmap entrypoints (no glibc call-through)",
      "hardened_semantics": "Same alias routing with membrane behavior inherited from target entrypoints",
      "default_stub": false
    },
    {
      "symbol": "fstatat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "fstatat64",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "LP64 alias to native unistd/io/mmap entrypoints (no glibc call-through)",
      "hardened_semantics": "Same alias routing with membrane behavior inherited from target entrypoints",
      "default_stub": false
    },
    {
      "symbol": "fsync",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "ftell",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Returns logical file offset from internal StdioStream state; no host glibc delegation",
      "hardened_semantics": "Native implementation; membrane validates stream ID, returns -1 with EBADF for invalid streams",
      "default_stub": false
    },
    {
      "symbol": "ftello",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Aliases ftell on LP64 (off_t == long).",
      "hardened_semantics": "Same.",
      "default_stub": "Returns -1"
    },
    {
      "symbol": "ftello64",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "default",
      "strict_semantics": "LP64 alias to native ftello implementation",
      "hardened_semantics": "LP64 alias to native ftello implementation",
      "default_stub": false
    },
    {
      "symbol": "ftruncate",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "ftruncate64",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "LP64 alias to native unistd/io/mmap entrypoints (no glibc call-through)",
      "hardened_semantics": "Same alias routing with membrane behavior inherited from target entrypoints",
      "default_stub": false
    },
    {
      "symbol": "ftrylockfile",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "ftw",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc ftw",
      "hardened_semantics": "Passthrough to glibc ftw",
      "default_stub": false
    },
    {
      "symbol": "funlockfile",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "fwprintf",
      "status": "GlibcCallThrough",
      "module": "wchar_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "fwrite",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "fwscanf",
      "status": "GlibcCallThrough",
      "module": "wchar_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "gai_strerror",
      "status": "Implemented",
      "module": "resolv_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Bootstrap resolver implementation: numeric getaddrinfo/getnameinfo + gai_strerror/freeaddrinfo with deterministic EAI_* failures",
      "hardened_semantics": "Resolver with deterministic repairs: invalid host/service normalized to safe defaults, evidence emitted",
      "default_stub": false
    },
    {
      "symbol": "get_avphys_pages",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "fast",
      "strict_semantics": "SYS_sysinfo-backed available-physical-page estimate normalized by sysconf page size",
      "hardened_semantics": "Same SYS_sysinfo projection with bounded arithmetic",
      "default_stub": false
    },
    {
      "symbol": "get_nprocs",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "fast",
      "strict_semantics": "Native CPU-online count via existing sysconf(_SC_NPROCESSORS_ONLN)",
      "hardened_semantics": "Same native sysconf-backed count with positive fallback",
      "default_stub": false
    },
    {
      "symbol": "get_nprocs_conf",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "fast",
      "strict_semantics": "Native configured-CPU count via existing sysconf(_SC_NPROCESSORS_CONF)",
      "hardened_semantics": "Same native sysconf-backed count with positive fallback",
      "default_stub": false
    },
    {
      "symbol": "get_phys_pages",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "fast",
      "strict_semantics": "SYS_sysinfo total-physical-page estimate normalized by sysconf page size",
      "hardened_semantics": "Same SYS_sysinfo projection with bounded arithmetic",
      "default_stub": false
    },
    {
      "symbol": "getaddrinfo",
      "status": "Implemented",
      "module": "resolv_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Bootstrap resolver implementation: numeric getaddrinfo/getnameinfo + gai_strerror/freeaddrinfo with deterministic EAI_* failures",
      "hardened_semantics": "Resolver with deterministic repairs: invalid host/service normalized to safe defaults, evidence emitted",
      "default_stub": false
    },
    {
      "symbol": "getc",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Function alias for fgetc; reads one byte from stream",
      "hardened_semantics": "Same as strict; inherits fgetc membrane checks",
      "default_stub": false
    },
    {
      "symbol": "getc_unlocked",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "getchar",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "getcwd",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "getdelim",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "strict_slow",
      "strict_semantics": "Read until delimiter with dynamic buffer allocation via malloc",
      "hardened_semantics": "Same as strict; validates all pointer arguments",
      "default_stub": false
    },
    {
      "symbol": "getdomainname",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_uname-backed domainname extraction with Linux-compatible truncation semantics",
      "hardened_semantics": "SYS_uname-backed domainname extraction with bounded copy/truncation",
      "default_stub": false
    },
    {
      "symbol": "getegid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "getentropy",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "getentropy via SYS_getrandom (max 256 bytes)",
      "hardened_semantics": "getentropy via SYS_getrandom (max 256 bytes)",
      "default_stub": false
    },
    {
      "symbol": "getenv",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "geteuid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "getgid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "getgrent",
      "status": "Implemented",
      "module": "grp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: iterates /etc/group entries sequentially",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getgrent_r",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "getgrgid",
      "status": "Implemented",
      "module": "grp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: looks up /etc/group by GID, returns thread-local static storage",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getgrgid_r",
      "status": "Implemented",
      "module": "grp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: reentrant getgrgid into caller buffer, ERANGE on insufficient space",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getgrnam",
      "status": "Implemented",
      "module": "grp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: looks up /etc/group by name, returns thread-local static storage",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getgrnam_r",
      "status": "Implemented",
      "module": "grp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: reentrant getgrnam into caller buffer, ERANGE on insufficient space",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getgrouplist",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "getgroups",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_getgroups; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates size parameter",
      "default_stub": false
    },
    {
      "symbol": "gethostbyaddr",
      "status": "Implemented",
      "module": "resolv_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc gethostbyaddr",
      "hardened_semantics": "Passthrough to glibc gethostbyaddr",
      "default_stub": false
    },
    {
      "symbol": "gethostbyaddr_r",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "gethostbyname",
      "status": "Implemented",
      "module": "resolv_abi",
      "perf_class": "default",
      "strict_semantics": "Deterministic numeric IPv4 + /etc/hosts lookup with thread-local hostent storage",
      "hardened_semantics": "Deterministic numeric IPv4 + /etc/hosts lookup with safe-default localhost fallback",
      "default_stub": false
    },
    {
      "symbol": "gethostbyname_r",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "fast",
      "strict_semantics": "Deterministic numeric IPv4 + /etc/hosts lookup into caller buffers; ERANGE/ENOENT deterministic failures",
      "hardened_semantics": "Deterministic lookup with safe-default fallback under repair mode and bounded buffer writes",
      "default_stub": false
    },
    {
      "symbol": "gethostid",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Deterministic hostid derived from uname nodename hash; no glibc dependency",
      "hardened_semantics": "Same deterministic hostid derivation; no mode divergence",
      "default_stub": false
    },
    {
      "symbol": "gethostname",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "getifaddrs",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "getitimer",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "getline",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "strict_slow",
      "strict_semantics": "Read line (newline-delimited); delegates to getdelim",
      "hardened_semantics": "Same as strict; validates all pointer arguments",
      "default_stub": false
    },
    {
      "symbol": "getlogin",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Resolves current effective UID through getpwuid and returns username via process-static buffer; sets errno on failure",
      "hardened_semantics": "Same as strict with runtime-policy resolver gating and deterministic failure paths",
      "default_stub": false
    },
    {
      "symbol": "getlogin_r",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Resolves current effective UID through getpwuid and copies username to caller buffer; returns EINVAL/ERANGE/ENOENT codes",
      "hardened_semantics": "Same as strict with runtime-policy resolver gating and deterministic error-code returns",
      "default_stub": false
    },
    {
      "symbol": "getmntent",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "getnameinfo",
      "status": "Implemented",
      "module": "resolv_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Bootstrap resolver implementation: numeric getaddrinfo/getnameinfo + gai_strerror/freeaddrinfo with deterministic EAI_* failures",
      "hardened_semantics": "Resolver with deterministic repairs: invalid host/service normalized to safe defaults, evidence emitted",
      "default_stub": false
    },
    {
      "symbol": "getopt",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native short-option parser honoring optarg/optind/opterr/optopt global state and POSIX '?' / ':' signaling",
      "hardened_semantics": "Same parser with runtime-policy observation and deterministic state updates",
      "default_stub": false
    },
    {
      "symbol": "getopt_long",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native long-option parser supporting no/required/optional args plus fallback to short-option parsing",
      "hardened_semantics": "Same parser with runtime-policy observation and deterministic state updates",
      "default_stub": false
    },
    {
      "symbol": "getpagesize",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Native page-size resolution via unistd sysconf table",
      "hardened_semantics": "Same native page-size resolution",
      "default_stub": false
    },
    {
      "symbol": "getpass",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "getpeername",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "getpgid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_getpgid; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates pid parameter",
      "default_stub": false
    },
    {
      "symbol": "getpid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "getppid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "getprotobyname",
      "status": "Implemented",
      "module": "resolv_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc getprotobyname",
      "hardened_semantics": "Passthrough to glibc getprotobyname",
      "default_stub": false
    },
    {
      "symbol": "getprotobynumber",
      "status": "Implemented",
      "module": "resolv_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc getprotobynumber",
      "hardened_semantics": "Passthrough to glibc getprotobynumber",
      "default_stub": false
    },
    {
      "symbol": "getpwent",
      "status": "Implemented",
      "module": "pwd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: iterates /etc/passwd entries sequentially",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getpwent_r",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "getpwnam",
      "status": "Implemented",
      "module": "pwd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: looks up /etc/passwd by username, returns thread-local static storage",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getpwnam_r",
      "status": "Implemented",
      "module": "pwd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: reentrant getpwnam into caller buffer, ERANGE on insufficient space",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getpwuid",
      "status": "Implemented",
      "module": "pwd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: looks up /etc/passwd by UID, returns thread-local static storage",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getpwuid_r",
      "status": "Implemented",
      "module": "pwd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: reentrant getpwuid into caller buffer, ERANGE on insufficient space",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getrandom",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_getrandom \u2014 kernel CSPRNG",
      "hardened_semantics": "SYS_getrandom \u2014 kernel CSPRNG",
      "default_stub": false
    },
    {
      "symbol": "getrlimit",
      "status": "RawSyscall",
      "module": "resource_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for getrlimit/setrlimit; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies invalid resource constants",
      "default_stub": false
    },
    {
      "symbol": "getrusage",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "getservbyname",
      "status": "Implemented",
      "module": "resolv_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc getservbyname",
      "hardened_semantics": "Passthrough to glibc getservbyname",
      "default_stub": false
    },
    {
      "symbol": "getservbyname_r",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "getservbyport",
      "status": "Implemented",
      "module": "resolv_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc getservbyport",
      "hardened_semantics": "Passthrough to glibc getservbyport",
      "default_stub": false
    },
    {
      "symbol": "getservbyport_r",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "getsid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_getsid; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates pid parameter",
      "default_stub": false
    },
    {
      "symbol": "getsockname",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "getsockopt",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "gettext",
      "status": "Implemented",
      "module": "locale_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc gettext",
      "hardened_semantics": "Passthrough to glibc gettext",
      "default_stub": false
    },
    {
      "symbol": "gettimeofday",
      "status": "RawSyscall",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall via clock_gettime(CLOCK_REALTIME); POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates tv pointer",
      "default_stub": false
    },
    {
      "symbol": "getuid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "getutent",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "getwchar",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "fast",
      "strict_semantics": "Native stdin wide-char read via fgetwc over stdio sentinel stream",
      "hardened_semantics": "Same deterministic WEOF contract with UTF-8 validation"
    },
    {
      "symbol": "getxattr",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_getxattr",
      "hardened_semantics": "SYS_getxattr",
      "default_stub": false
    },
    {
      "symbol": "glob",
      "status": "GlibcCallThrough",
      "module": "string_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc glob",
      "hardened_semantics": "Passthrough to glibc glob",
      "default_stub": false
    },
    {
      "symbol": "globfree",
      "status": "GlibcCallThrough",
      "module": "string_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc globfree",
      "hardened_semantics": "Passthrough to glibc globfree",
      "default_stub": false
    },
    {
      "symbol": "gmtime",
      "status": "Implemented",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Thread-local buffer wrapping gmtime_r. Returns pointer to static tm.",
      "hardened_semantics": "Same. Null pointer returns NULL.",
      "default_stub": "Returns NULL"
    },
    {
      "symbol": "gmtime_r",
      "status": "Implemented",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure Rust epoch_to_broken_down conversion to UTC; no syscall",
      "hardened_semantics": "Pure Rust conversion with null pointer guard",
      "default_stub": false
    },
    {
      "symbol": "grantpt",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Validates PTY master fd via ioctl(TIOCGPTN); returns 0 or -1 with POSIX errno",
      "hardened_semantics": "Same ioctl validation path with deterministic errno propagation for invalid descriptors",
      "default_stub": false
    },
    {
      "symbol": "hasmntopt",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "herror",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "fast",
      "strict_semantics": "Formats `<prefix>: <resolver-message>\\n` to stderr using thread-local h_errno",
      "hardened_semantics": "Same stderr formatting path with deterministic message mapping and write semantics",
      "default_stub": false
    },
    {
      "symbol": "hstrerror",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "fast",
      "strict_semantics": "Maps resolver error codes to stable static C-string messages",
      "hardened_semantics": "Same deterministic resolver error-message mapping for all input codes",
      "default_stub": false
    },
    {
      "symbol": "htonl",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure-computation byte-order and address conversion; no syscalls",
      "hardened_semantics": "Pure computation; no mode difference",
      "default_stub": false
    },
    {
      "symbol": "htons",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure-computation byte-order and address conversion; no syscalls",
      "hardened_semantics": "Pure computation; no mode difference",
      "default_stub": false
    },
    {
      "symbol": "hypot",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; finite overflow to infinity sets errno=ERANGE while preserving IEEE 754 behavior",
      "hardened_semantics": "Same ERANGE overflow signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "hypotf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "iconv",
      "status": "Implemented",
      "module": "iconv_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Phase-1 iconv implementation for UTF-8/ISO-8859-1/UTF-16LE/UTF-32 with deterministic errno semantics",
      "hardened_semantics": "Phase-1 iconv with hardened membrane routing; deterministic bounds/error behavior",
      "default_stub": false
    },
    {
      "symbol": "iconv_close",
      "status": "Implemented",
      "module": "iconv_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Phase-1 iconv implementation for UTF-8/ISO-8859-1/UTF-16LE/UTF-32 with deterministic errno semantics",
      "hardened_semantics": "Phase-1 iconv with hardened membrane routing; deterministic bounds/error behavior",
      "default_stub": false
    },
    {
      "symbol": "iconv_open",
      "status": "Implemented",
      "module": "iconv_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Phase-1 iconv implementation for UTF-8/ISO-8859-1/UTF-16LE/UTF-32 with deterministic errno semantics",
      "hardened_semantics": "Phase-1 iconv with hardened membrane routing; deterministic bounds/error behavior",
      "default_stub": false
    },
    {
      "symbol": "if_freenameindex",
      "status": "GlibcCallThrough",
      "module": "inet_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "if_indextoname",
      "status": "RawSyscall",
      "module": "inet_abi",
      "perf_class": "default",
      "strict_semantics": "ioctl SIOCGIFNAME via raw syscall",
      "hardened_semantics": "ioctl SIOCGIFNAME via raw syscall",
      "default_stub": false
    },
    {
      "symbol": "if_nameindex",
      "status": "GlibcCallThrough",
      "module": "inet_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "if_nametoindex",
      "status": "RawSyscall",
      "module": "inet_abi",
      "perf_class": "default",
      "strict_semantics": "ioctl SIOCGIFINDEX via raw syscall",
      "hardened_semantics": "ioctl SIOCGIFINDEX via raw syscall",
      "default_stub": false
    },
    {
      "symbol": "ilogb",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "ilogbf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "index",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Alias for strchr",
      "hardened_semantics": "Same as strchr hardened semantics",
      "default_stub": false
    },
    {
      "symbol": "inet_addr",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure-computation byte-order and address conversion; no syscalls",
      "hardened_semantics": "Pure computation; no mode difference",
      "default_stub": false
    },
    {
      "symbol": "inet_aton",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Parse dotted-quad IPv4 text to in_addr; returns 1 on success, 0 on failure",
      "hardened_semantics": "Same as strict; pure compute with no mode difference",
      "default_stub": false
    },
    {
      "symbol": "inet_ntoa",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Convert IPv4 in_addr to dotted-quad string in thread-local buffer; not reentrant",
      "hardened_semantics": "Same as strict; pure compute with no mode difference",
      "default_stub": false
    },
    {
      "symbol": "inet_ntop",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure-computation byte-order and address conversion; no syscalls",
      "hardened_semantics": "Pure computation; no mode difference",
      "default_stub": false
    },
    {
      "symbol": "inet_pton",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure-computation byte-order and address conversion; no syscalls",
      "hardened_semantics": "Pure computation; no mode difference",
      "default_stub": false
    },
    {
      "symbol": "initgroups",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall"
    },
    {
      "symbol": "inotify_add_watch",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "inotify_init",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "inotify_init1",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "inotify_rm_watch",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "ioctl",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "isalnum",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "isalpha",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "isascii",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "trivial",
      "strict_semantics": "pass-through",
      "hardened_semantics": "pass-through",
      "default_stub": false
    },
    {
      "symbol": "isatty",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "isblank",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "trivial",
      "strict_semantics": "pass-through",
      "hardened_semantics": "pass-through",
      "default_stub": false
    },
    {
      "symbol": "iscntrl",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "trivial",
      "strict_semantics": "pass-through",
      "hardened_semantics": "pass-through",
      "default_stub": false
    },
    {
      "symbol": "isdigit",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "isgraph",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "trivial",
      "strict_semantics": "pass-through",
      "hardened_semantics": "pass-through",
      "default_stub": false
    },
    {
      "symbol": "islower",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "isprint",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "ispunct",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "isspace",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "isupper",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "iswalnum",
      "header": "wctype.h",
      "family": "wctype",
      "status": "Implemented",
      "notes": "Wide character alphanumeric test"
    },
    {
      "symbol": "iswalpha",
      "header": "wctype.h",
      "family": "wctype",
      "status": "Implemented",
      "notes": "Wide character alphabetic test"
    },
    {
      "symbol": "iswblank",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "iswcntrl",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "iswdigit",
      "header": "wctype.h",
      "family": "wctype",
      "status": "Implemented",
      "notes": "Wide character digit test"
    },
    {
      "symbol": "iswgraph",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "iswlower",
      "header": "wctype.h",
      "family": "wctype",
      "status": "Implemented",
      "notes": "Wide character lowercase test"
    },
    {
      "symbol": "iswprint",
      "header": "wctype.h",
      "family": "wctype",
      "status": "Implemented",
      "notes": "Wide character printable test"
    },
    {
      "symbol": "iswpunct",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "iswspace",
      "header": "wctype.h",
      "family": "wctype",
      "status": "Implemented",
      "notes": "Wide character whitespace test"
    },
    {
      "symbol": "iswupper",
      "header": "wctype.h",
      "family": "wctype",
      "status": "Implemented",
      "notes": "Wide character uppercase test"
    },
    {
      "symbol": "iswxdigit",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "isxdigit",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "kill",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for signal handling; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies invalid signal numbers instead of passing to kernel",
      "default_stub": false
    },
    {
      "symbol": "killpg",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall via kill(-pgrp, sig); POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates pgrp non-negative and signal number before passing to kernel",
      "default_stub": false
    },
    {
      "symbol": "labs",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Long absolute value via wrapping_abs",
      "hardened_semantics": "No mode difference; pure computation",
      "default_stub": false
    },
    {
      "symbol": "lchown",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "ldexp",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "ldexpf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "ldiv",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Long division returning quotient and remainder; zero-denom returns zero",
      "hardened_semantics": "No mode difference; pure computation",
      "default_stub": false
    },
    {
      "symbol": "lgamma",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; poles at zero/negative integers and overflow regimes set errno=ERANGE",
      "hardened_semantics": "Same ERANGE signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "lgammaf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "lgetxattr",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall"
    },
    {
      "symbol": "link",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "linkat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "lio_listio",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "syscall"
    },
    {
      "symbol": "listen",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "listxattr",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_listxattr",
      "hardened_semantics": "SYS_listxattr",
      "default_stub": false
    },
    {
      "symbol": "llabs",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Long long absolute value via wrapping_abs",
      "hardened_semantics": "No mode difference; pure computation",
      "default_stub": false
    },
    {
      "symbol": "lldiv",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Long long division returning quotient and remainder; zero-denom returns zero",
      "hardened_semantics": "No mode difference; pure computation",
      "default_stub": false
    },
    {
      "symbol": "llistxattr",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall"
    },
    {
      "symbol": "llrint",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "llrintf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "llround",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "llroundf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "localeconv",
      "status": "Implemented",
      "module": "locale_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Bootstrap locale implementation: setlocale supports C/POSIX and localeconv returns static C locale struct",
      "hardened_semantics": "Locale implementation with hardened fallback to C locale defaults on invalid input",
      "default_stub": false
    },
    {
      "symbol": "localtime",
      "status": "Implemented",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Thread-local buffer wrapping localtime_r. Returns pointer to static tm.",
      "hardened_semantics": "Same. Null pointer returns NULL.",
      "default_stub": "Returns NULL"
    },
    {
      "symbol": "localtime_r",
      "status": "RawSyscall",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for time queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; defaults invalid clock_id to CLOCK_REALTIME",
      "default_stub": false
    },
    {
      "symbol": "lockf",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Translates lockf commands to fcntl byte-range lock operations via raw lseek/fcntl syscalls; sets errno on failure",
      "hardened_semantics": "Same syscall path with runtime-policy deny gate and deterministic errno mapping",
      "default_stub": false
    },
    {
      "symbol": "log",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; x<0 sets errno=EDOM and x==0 sets errno=ERANGE with IEEE 754 outputs preserved",
      "hardened_semantics": "Same errno domain/range signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "log10",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; x<0 sets errno=EDOM and x==0 sets errno=ERANGE with IEEE 754 outputs preserved",
      "hardened_semantics": "Same errno domain/range signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "log10f",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "log1p",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; x<-1 sets errno=EDOM and x==-1 sets errno=ERANGE with IEEE 754 outputs preserved",
      "hardened_semantics": "Same errno domain/range signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "log1pf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "log2",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; x<0 sets errno=EDOM and x==0 sets errno=ERANGE with IEEE 754 outputs preserved",
      "hardened_semantics": "Same errno domain/range signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "log2f",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "logb",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "logbf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "logf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "login_tty",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Native setsid+ioctl TIOCSCTTY+dup2 via raw syscalls",
      "hardened_semantics": "Native setsid+ioctl TIOCSCTTY+dup2 via raw syscalls",
      "default_stub": false
    },
    {
      "symbol": "longjmp",
      "status": "Implemented",
      "module": "setjmp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Phase-1 restore with validation. Terminates (deferred backend).",
      "hardened_semantics": "Same.",
      "default_stub": "Aborts"
    },
    {
      "symbol": "lremovexattr",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall"
    },
    {
      "symbol": "lrint",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "lrintf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "lround",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "lroundf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "lseek",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "lseek64",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "LP64 alias to native unistd/io/mmap entrypoints (no glibc call-through)",
      "hardened_semantics": "Same alias routing with membrane behavior inherited from target entrypoints",
      "default_stub": false
    },
    {
      "symbol": "lsetxattr",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall"
    },
    {
      "symbol": "lstat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "lstat64",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "LP64 alias to native unistd/io/mmap entrypoints (no glibc call-through)",
      "hardened_semantics": "Same alias routing with membrane behavior inherited from target entrypoints",
      "default_stub": false
    },
    {
      "symbol": "madvise",
      "status": "RawSyscall",
      "module": "mmap_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for virtual memory; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies conflicting prot/flags combinations",
      "default_stub": false
    },
    {
      "symbol": "malloc",
      "status": "Implemented",
      "module": "malloc_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust arena allocator; null on failure; double-free silently ignored",
      "hardened_semantics": "Arena with healing: foreign-ptr realloc as malloc, double-free logged as HealingAction",
      "default_stub": false
    },
    {
      "symbol": "mblen",
      "header": "stdlib.h",
      "family": "wchar",
      "status": "Implemented",
      "notes": "UTF-8 multibyte character length"
    },
    {
      "symbol": "mbrtowc",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Stateless UTF-8 multibyte decode with POSIX mbrtowc return contract for success/incomplete/invalid input",
      "hardened_semantics": "Same decode semantics with deterministic EILSEQ and membrane-aware deny/repair behavior",
      "default_stub": false
    },
    {
      "symbol": "mbsrtowcs",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Stateless UTF-8 multibyte-string to wide-string conversion with source-pointer progress contract",
      "hardened_semantics": "Same conversion with deterministic EILSEQ on invalid bytes and bounded destination writes",
      "default_stub": false
    },
    {
      "symbol": "mbstowcs",
      "header": "stdlib.h",
      "family": "wchar",
      "status": "Implemented",
      "notes": "UTF-8 multibyte string to wide string"
    },
    {
      "symbol": "mbtowc",
      "header": "stdlib.h",
      "family": "wchar",
      "status": "Implemented",
      "notes": "UTF-8 multibyte to wide character"
    },
    {
      "symbol": "memalign",
      "status": "Implemented",
      "module": "malloc_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust arena allocator; null on failure; double-free silently ignored",
      "hardened_semantics": "Arena with healing: foreign-ptr realloc as malloc, double-free logged as HealingAction",
      "default_stub": false
    },
    {
      "symbol": "memccpy",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust byte copy until stop character; no repair",
      "hardened_semantics": "Clamps copy length to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "memchr",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "memcmp",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "memcpy",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "memfd_create",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_memfd_create \u2014 anonymous file in memory",
      "hardened_semantics": "SYS_memfd_create \u2014 anonymous file in memory",
      "default_stub": false
    },
    {
      "symbol": "memmem",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust subsequence search via sliding window; no repair",
      "hardened_semantics": "Clamps haystack/needle to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "memmove",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "mempcpy",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust memcpy variant returning pointer past last written byte; no repair",
      "hardened_semantics": "Clamps copy to tracked allocation bounds; returns clamped end pointer",
      "default_stub": false
    },
    {
      "symbol": "memrchr",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "memset",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "mincore",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_mincore",
      "hardened_semantics": "SYS_mincore",
      "default_stub": false
    },
    {
      "symbol": "mkdir",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "mkdirat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "mkdtemp",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Native XXXXXX suffix rewrite with bounded candidate loop and mkdir(0700)",
      "hardened_semantics": "Same native bounded directory creation path with runtime-policy deny/observe gate",
      "default_stub": false
    },
    {
      "symbol": "mkfifo",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "mknod",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "mkostemp",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "default",
      "strict_semantics": "Native template replacement + O_CREAT|O_EXCL open loop with mkostemp-allowed flags",
      "hardened_semantics": "Same deterministic unique-name open loop with runtime-policy deny/observe path",
      "default_stub": false
    },
    {
      "symbol": "mkostemps",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "syscall",
      "strict_semantics": "Native mkstemp-style creation preserving caller suffix and honoring mkostemps flag subset",
      "hardened_semantics": "Same suffix-preserving unique-name creation with runtime-policy deny/observe path",
      "default_stub": false
    },
    {
      "symbol": "mkstemp",
      "header": "stdlib.h",
      "family": "unistd",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "syscall",
      "strict_semantics": "Native alias to mkstemps(template, 0) with XXXXXX replacement and O_CREAT|O_EXCL open",
      "hardened_semantics": "Same native alias path with runtime-policy deny/observe gate",
      "default_stub": false
    },
    {
      "symbol": "mkstemps",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "syscall",
      "strict_semantics": "Native mkstemp-style creation preserving caller suffix with O_CREAT|O_EXCL open",
      "hardened_semantics": "Same suffix-preserving unique-name creation with runtime-policy deny/observe path",
      "default_stub": false
    },
    {
      "symbol": "mktime",
      "status": "Implemented",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure Rust broken_down_to_epoch with field normalization; UTC only",
      "hardened_semantics": "Pure Rust conversion; normalizes fields, UTC only",
      "default_stub": false
    },
    {
      "symbol": "mlock",
      "status": "RawSyscall",
      "module": "mmap_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "mlockall",
      "status": "RawSyscall",
      "module": "mmap_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "mmap",
      "status": "RawSyscall",
      "module": "mmap_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for virtual memory; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies conflicting prot/flags combinations",
      "default_stub": false
    },
    {
      "symbol": "mmap64",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "LP64 alias to native unistd/io/mmap entrypoints (no glibc call-through)",
      "hardened_semantics": "Same alias routing with membrane behavior inherited from target entrypoints",
      "default_stub": false
    },
    {
      "symbol": "modf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "modff",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "mprotect",
      "status": "RawSyscall",
      "module": "mmap_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for virtual memory; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies conflicting prot/flags combinations",
      "default_stub": false
    },
    {
      "symbol": "mq_close",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_close on message-queue descriptor",
      "hardened_semantics": "SYS_close on message-queue descriptor",
      "default_stub": false
    },
    {
      "symbol": "mq_getattr",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_mq_getsetattr with newattr=NULL",
      "hardened_semantics": "SYS_mq_getsetattr with newattr=NULL",
      "default_stub": false
    },
    {
      "symbol": "mq_open",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_mq_open with O_CREAT varargs (mode, attr)",
      "hardened_semantics": "SYS_mq_open with O_CREAT varargs (mode, attr)",
      "default_stub": false
    },
    {
      "symbol": "mq_receive",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_mq_timedreceive with timeout=NULL",
      "hardened_semantics": "SYS_mq_timedreceive with timeout=NULL",
      "default_stub": false
    },
    {
      "symbol": "mq_send",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_mq_timedsend with timeout=NULL",
      "hardened_semantics": "SYS_mq_timedsend with timeout=NULL",
      "default_stub": false
    },
    {
      "symbol": "mq_setattr",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_mq_getsetattr with oldattr capture",
      "hardened_semantics": "SYS_mq_getsetattr with oldattr capture",
      "default_stub": false
    },
    {
      "symbol": "mq_unlink",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_mq_unlink",
      "hardened_semantics": "SYS_mq_unlink",
      "default_stub": false
    },
    {
      "symbol": "mremap",
      "status": "RawSyscall",
      "module": "mmap_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_mremap \u2014 remap virtual memory",
      "hardened_semantics": "SYS_mremap \u2014 remap virtual memory",
      "default_stub": false
    },
    {
      "symbol": "msgctl",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall",
      "strict_semantics": "SYS_msgctl",
      "hardened_semantics": "SYS_msgctl",
      "default_stub": false
    },
    {
      "symbol": "msgget",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall",
      "strict_semantics": "SYS_msgget",
      "hardened_semantics": "SYS_msgget",
      "default_stub": false
    },
    {
      "symbol": "msgrcv",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall",
      "strict_semantics": "SYS_msgrcv",
      "hardened_semantics": "SYS_msgrcv",
      "default_stub": false
    },
    {
      "symbol": "msgsnd",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall",
      "strict_semantics": "SYS_msgsnd",
      "hardened_semantics": "SYS_msgsnd",
      "default_stub": false
    },
    {
      "symbol": "msync",
      "status": "RawSyscall",
      "module": "mmap_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for virtual memory; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies conflicting prot/flags combinations",
      "default_stub": false
    },
    {
      "symbol": "munlock",
      "status": "RawSyscall",
      "module": "mmap_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "munlockall",
      "status": "RawSyscall",
      "module": "mmap_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "munmap",
      "status": "RawSyscall",
      "module": "mmap_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for virtual memory; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies conflicting prot/flags combinations",
      "default_stub": false
    },
    {
      "symbol": "nanosleep",
      "status": "RawSyscall",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_nanosleep; sets errno EINTR on signal interruption",
      "hardened_semantics": "Raw syscall; validates req pointer",
      "default_stub": false
    },
    {
      "symbol": "nearbyint",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "nearbyintf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "nextafter",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "nextafterf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "nftw",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc nftw",
      "hardened_semantics": "Passthrough to glibc nftw",
      "default_stub": false
    },
    {
      "symbol": "ngettext",
      "status": "Implemented",
      "module": "locale_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc ngettext",
      "hardened_semantics": "Passthrough to glibc ngettext",
      "default_stub": false
    },
    {
      "symbol": "nice",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_nice \u2014 adjust calling process niceness by increment and return updated value",
      "hardened_semantics": "SYS_nice \u2014 same syscall path with deterministic errno propagation",
      "default_stub": false
    },
    {
      "symbol": "nl_langinfo",
      "header": "langinfo.h",
      "status": "GlibcCallThrough",
      "module": "locale_abi",
      "notes": ""
    },
    {
      "symbol": "ntohl",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure-computation byte-order and address conversion; no syscalls",
      "hardened_semantics": "Pure computation; no mode difference",
      "default_stub": false
    },
    {
      "symbol": "ntohs",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure-computation byte-order and address conversion; no syscalls",
      "hardened_semantics": "Pure computation; no mode difference",
      "default_stub": false
    },
    {
      "symbol": "open",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "open64",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "LP64 alias to native unistd/io/mmap entrypoints (no glibc call-through)",
      "hardened_semantics": "Same alias routing with membrane behavior inherited from target entrypoints",
      "default_stub": false
    },
    {
      "symbol": "open_memstream",
      "status": "GlibcCallThrough",
      "module": "stdio_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "openat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "opendir",
      "status": "RawSyscall",
      "module": "dirent_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for directory enumeration; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates path pointer bounds before getdents64",
      "default_stub": false
    },
    {
      "symbol": "openlog",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc openlog",
      "hardened_semantics": "Passthrough to glibc openlog",
      "default_stub": false
    },
    {
      "symbol": "openpty",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc openpty",
      "hardened_semantics": "Passthrough to glibc openpty",
      "default_stub": false
    },
    {
      "symbol": "pathconf",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native path existence validation + pathconf value table; ENOENT/EINVAL contract preserved",
      "hardened_semantics": "Same value table with runtime-policy deny handling and deterministic EPERM failure path",
      "default_stub": false
    },
    {
      "symbol": "pause",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_pause; always returns -1 with EINTR",
      "hardened_semantics": "Raw syscall; membrane-gated suspension with EINTR on signal delivery",
      "default_stub": false
    },
    {
      "symbol": "pclose",
      "header": "stdio.h",
      "status": "Implemented",
      "module": "stdio_abi",
      "notes": ""
    },
    {
      "symbol": "perror",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native errno-to-message mapping with direct write to stderr fd; no host glibc delegation",
      "hardened_semantics": "Native implementation; membrane validates optional prefix string, logs TruncateWithNull for unterminated strings",
      "default_stub": false
    },
    {
      "symbol": "pidfd_open",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_pidfd_open \u2014 process file descriptor",
      "hardened_semantics": "SYS_pidfd_open \u2014 process file descriptor",
      "default_stub": false
    },
    {
      "symbol": "pidfd_send_signal",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_pidfd_send_signal \u2014 signal via pidfd",
      "hardened_semantics": "SYS_pidfd_send_signal \u2014 signal via pidfd",
      "default_stub": false
    },
    {
      "symbol": "pipe",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for dup/dup2/pipe/fcntl; POSIX errno on failure",
      "hardened_semantics": "Raw syscall with hardened membrane; repair on invalid flags",
      "default_stub": false
    },
    {
      "symbol": "pipe2",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "poll",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for I/O multiplexing; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps nfds to tracked pollfd array bounds",
      "default_stub": false
    },
    {
      "symbol": "popen",
      "header": "stdio.h",
      "status": "Implemented",
      "module": "stdio_abi",
      "notes": ""
    },
    {
      "symbol": "posix_fadvise",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_fadvise64",
      "hardened_semantics": "SYS_fadvise64",
      "default_stub": false
    },
    {
      "symbol": "posix_fallocate",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Invokes Linux fallocate syscall and returns POSIX error codes directly (0 on success, errno value on failure)",
      "hardened_semantics": "Same syscall path with runtime-policy gate; invalid ranges return EINVAL and deny returns EPERM code",
      "default_stub": false
    },
    {
      "symbol": "posix_madvise",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Invokes Linux madvise syscall and returns POSIX error codes directly without mutating errno",
      "hardened_semantics": "Same syscall path with runtime-policy gate; deny returns EPERM code",
      "default_stub": false
    },
    {
      "symbol": "posix_memalign",
      "status": "Implemented",
      "module": "malloc_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust arena allocator; null on failure; double-free silently ignored",
      "hardened_semantics": "Arena with healing: foreign-ptr realloc as malloc, double-free logged as HealingAction",
      "default_stub": false
    },
    {
      "symbol": "posix_openpt",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Invokes SYS_openat on /dev/ptmx with caller flags; returns fd or -1 with POSIX errno",
      "hardened_semantics": "Same raw openat path; invalid flags/descriptors surface deterministic kernel errno",
      "default_stub": false
    },
    {
      "symbol": "posix_spawn",
      "status": "GlibcCallThrough",
      "module": "process_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc posix_spawn",
      "hardened_semantics": "Passthrough to glibc posix_spawn",
      "default_stub": false
    },
    {
      "symbol": "posix_spawn_file_actions_destroy",
      "status": "GlibcCallThrough",
      "module": "process_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc posix_spawn_file_actions_destroy",
      "hardened_semantics": "Passthrough to glibc posix_spawn_file_actions_destroy",
      "default_stub": false
    },
    {
      "symbol": "posix_spawn_file_actions_init",
      "status": "GlibcCallThrough",
      "module": "process_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc posix_spawn_file_actions_init",
      "hardened_semantics": "Passthrough to glibc posix_spawn_file_actions_init",
      "default_stub": false
    },
    {
      "symbol": "posix_spawnattr_destroy",
      "status": "GlibcCallThrough",
      "module": "process_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc posix_spawnattr_destroy",
      "hardened_semantics": "Passthrough to glibc posix_spawnattr_destroy",
      "default_stub": false
    },
    {
      "symbol": "posix_spawnattr_init",
      "status": "GlibcCallThrough",
      "module": "process_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc posix_spawnattr_init",
      "hardened_semantics": "Passthrough to glibc posix_spawnattr_init",
      "default_stub": false
    },
    {
      "symbol": "posix_spawnp",
      "status": "GlibcCallThrough",
      "module": "process_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc posix_spawnp",
      "hardened_semantics": "Passthrough to glibc posix_spawnp",
      "default_stub": false
    },
    {
      "symbol": "pow",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; 0^negative and finite overflow/underflow set errno=ERANGE, negative base with fractional exponent sets errno=EDOM",
      "hardened_semantics": "Same errno signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "powf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "ppoll",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for I/O multiplexing; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps nfds to tracked pollfd array bounds",
      "default_stub": false
    },
    {
      "symbol": "prctl",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "pread",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "pread64",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "LP64 alias to native unistd/io/mmap entrypoints (no glibc call-through)",
      "hardened_semantics": "Same alias routing with membrane behavior inherited from target entrypoints",
      "default_stub": false
    },
    {
      "symbol": "preadv",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_preadv \u2014 vectored pread",
      "hardened_semantics": "SYS_preadv \u2014 vectored pread",
      "default_stub": false
    },
    {
      "symbol": "preadv2",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_preadv2 \u2014 vectored pread with flags",
      "hardened_semantics": "SYS_preadv2 \u2014 vectored pread with flags",
      "default_stub": false
    },
    {
      "symbol": "printf",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native printf engine writing directly to stdout via syscall-backed path; no host glibc call-through",
      "hardened_semantics": "Native printf engine + membrane validation/repair on stdout path; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "prlimit",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall"
    },
    {
      "symbol": "prlimit64",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall"
    },
    {
      "symbol": "pselect",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for I/O multiplexing; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps nfds to tracked pollfd array bounds",
      "default_stub": false
    },
    {
      "symbol": "psignal",
      "status": "RawSyscall",
      "module": "string_abi",
      "perf_class": "default",
      "strict_semantics": "Native signal name lookup + SYS_write to stderr",
      "hardened_semantics": "Native signal name lookup + SYS_write to stderr",
      "default_stub": false
    },
    {
      "symbol": "pthread_attr_destroy",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to glibc.",
      "hardened_semantics": "Same.",
      "default_stub": "Returns EINVAL"
    },
    {
      "symbol": "pthread_attr_getdetachstate",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to glibc.",
      "hardened_semantics": "Same.",
      "default_stub": "Returns EINVAL"
    },
    {
      "symbol": "pthread_attr_getstacksize",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to glibc.",
      "hardened_semantics": "Same.",
      "default_stub": "Returns EINVAL"
    },
    {
      "symbol": "pthread_attr_init",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to glibc.",
      "hardened_semantics": "Same.",
      "default_stub": "Returns EINVAL"
    },
    {
      "symbol": "pthread_attr_setdetachstate",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to glibc.",
      "hardened_semantics": "Same.",
      "default_stub": "Returns EINVAL"
    },
    {
      "symbol": "pthread_attr_setstacksize",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to glibc.",
      "hardened_semantics": "Same.",
      "default_stub": "Returns EINVAL"
    },
    {
      "symbol": "pthread_barrier_destroy",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough",
      "hardened_semantics": "Passthrough",
      "default_stub": false
    },
    {
      "symbol": "pthread_barrier_init",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough",
      "hardened_semantics": "Passthrough",
      "default_stub": false
    },
    {
      "symbol": "pthread_barrier_wait",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough",
      "hardened_semantics": "Passthrough",
      "default_stub": false
    },
    {
      "symbol": "pthread_cancel",
      "status": "GlibcCallThrough",
      "module": "pthread_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc pthread_cancel",
      "hardened_semantics": "Passthrough to glibc pthread_cancel",
      "default_stub": false
    },
    {
      "symbol": "pthread_cond_broadcast",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native futex-backed condvar implementation; requires managed mutex association and returns deterministic errno on invalid state",
      "hardened_semantics": "Native futex-backed condvar with deterministic validation of cond/mutex association and bounded wake behavior",
      "default_stub": false
    },
    {
      "symbol": "pthread_cond_destroy",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native condvar destroy returns EBUSY when waiters are present and clears association on success",
      "hardened_semantics": "Native condvar destroy enforces waiter-count invariants with deterministic EBUSY/EINVAL outcomes",
      "default_stub": false
    },
    {
      "symbol": "pthread_cond_init",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native condvar initialization with deterministic default clock and null/attr validation contract",
      "hardened_semantics": "Native condvar initialization with deterministic pointer validation and explicit unsupported-attribute rejection",
      "default_stub": false
    },
    {
      "symbol": "pthread_cond_signal",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native futex-backed condvar signal increments sequence and wakes one waiter when present",
      "hardened_semantics": "Native futex-backed condvar signal with deterministic wake policy and invariant-preserving sequence updates",
      "default_stub": false
    },
    {
      "symbol": "pthread_cond_timedwait",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Timed condvar wait with futex backend.",
      "hardened_semantics": "Same.",
      "default_stub": "Returns EINVAL"
    },
    {
      "symbol": "pthread_cond_wait",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native condvar wait with futex choreography; requires managed mutex and enforces association invariants",
      "hardened_semantics": "Native condvar wait with deterministic validation, bounded wake/relock path, and explicit EINVAL on invalid association",
      "default_stub": false
    },
    {
      "symbol": "pthread_condattr_destroy",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to glibc.",
      "hardened_semantics": "Same.",
      "default_stub": "Returns EINVAL"
    },
    {
      "symbol": "pthread_condattr_getclock",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to glibc.",
      "hardened_semantics": "Same.",
      "default_stub": "Returns EINVAL"
    },
    {
      "symbol": "pthread_condattr_init",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to glibc.",
      "hardened_semantics": "Same.",
      "default_stub": "Returns EINVAL"
    },
    {
      "symbol": "pthread_condattr_setclock",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to glibc.",
      "hardened_semantics": "Same.",
      "default_stub": "Returns EINVAL"
    },
    {
      "symbol": "pthread_create",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native clone-backed thread creation via core ThreadHandle; null thread_out/start rejected with EINVAL and non-null attr rejected deterministically",
      "hardened_semantics": "Native clone-backed thread creation with membrane policy gating and deterministic handle-registry ownership checks",
      "default_stub": false
    },
    {
      "symbol": "pthread_detach",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native detach on managed ThreadHandle registry; unknown or already-consumed thread ids return deterministic ESRCH",
      "hardened_semantics": "Native detach with membrane policy gating and deterministic registry ownership enforcement",
      "default_stub": false
    },
    {
      "symbol": "pthread_equal",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native pthread_t identity comparison (reflexive equality over managed handle ids and fallback tid ids)",
      "hardened_semantics": "Native identity comparison under membrane policy routing with deterministic 0/1 return",
      "default_stub": false
    },
    {
      "symbol": "pthread_getattr_np",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc pthread_getattr_np",
      "hardened_semantics": "Passthrough to glibc pthread_getattr_np",
      "default_stub": false
    },
    {
      "symbol": "pthread_getname_np",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough",
      "hardened_semantics": "Passthrough",
      "default_stub": false
    },
    {
      "symbol": "pthread_getspecific",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Thread-specific data retrieval.",
      "hardened_semantics": "Same.",
      "default_stub": "Returns NULL"
    },
    {
      "symbol": "pthread_join",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native join on managed ThreadHandle registry with deterministic ESRCH for unknown ids and core join errno propagation",
      "hardened_semantics": "Native join with membrane policy gating and deterministic registry ownership enforcement",
      "default_stub": false
    },
    {
      "symbol": "pthread_key_create",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Thread-specific data key creation.",
      "hardened_semantics": "Same.",
      "default_stub": "Returns EINVAL"
    },
    {
      "symbol": "pthread_key_delete",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Thread-specific data key deletion.",
      "hardened_semantics": "Same.",
      "default_stub": "Returns EINVAL"
    },
    {
      "symbol": "pthread_mutex_destroy",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Futex-managed NORMAL mutex core; supports init(NULL attr) and lazy promotion for zero-initialized default mutexes; unsupported attributed/foreign layouts return deterministic EINVAL",
      "hardened_semantics": "Same futex-managed core with deterministic spin/wait/wake telemetry and identical errno contract",
      "default_stub": false
    },
    {
      "symbol": "pthread_mutex_init",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Futex-managed NORMAL mutex core; supports init(NULL attr) and lazy promotion for zero-initialized default mutexes; unsupported attributed/foreign layouts return deterministic EINVAL",
      "hardened_semantics": "Same futex-managed core with deterministic spin/wait/wake telemetry and identical errno contract",
      "default_stub": false
    },
    {
      "symbol": "pthread_mutex_lock",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Futex-managed NORMAL mutex core; supports init(NULL attr) and lazy promotion for zero-initialized default mutexes; unsupported attributed/foreign layouts return deterministic EINVAL",
      "hardened_semantics": "Same futex-managed core with deterministic spin/wait/wake telemetry and identical errno contract",
      "default_stub": false
    },
    {
      "symbol": "pthread_mutex_trylock",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Futex-managed NORMAL mutex core; supports init(NULL attr) and lazy promotion for zero-initialized default mutexes; unsupported attributed/foreign layouts return deterministic EINVAL",
      "hardened_semantics": "Same futex-managed core with deterministic spin/wait/wake telemetry and identical errno contract",
      "default_stub": false
    },
    {
      "symbol": "pthread_mutex_unlock",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Futex-managed NORMAL mutex core; supports init(NULL attr) and lazy promotion for zero-initialized default mutexes; unsupported attributed/foreign layouts return deterministic EINVAL",
      "hardened_semantics": "Same futex-managed core with deterministic spin/wait/wake telemetry and identical errno contract",
      "default_stub": false
    },
    {
      "symbol": "pthread_mutexattr_destroy",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to glibc.",
      "hardened_semantics": "Same.",
      "default_stub": "Returns EINVAL"
    },
    {
      "symbol": "pthread_mutexattr_gettype",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to glibc.",
      "hardened_semantics": "Same.",
      "default_stub": "Returns EINVAL"
    },
    {
      "symbol": "pthread_mutexattr_init",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to glibc.",
      "hardened_semantics": "Same.",
      "default_stub": "Returns EINVAL"
    },
    {
      "symbol": "pthread_mutexattr_settype",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to glibc.",
      "hardened_semantics": "Same.",
      "default_stub": "Returns EINVAL"
    },
    {
      "symbol": "pthread_once",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "coldpath",
      "strict_semantics": "One-time initialization with futex-based once control.",
      "hardened_semantics": "Same.",
      "default_stub": "Returns EINVAL"
    },
    {
      "symbol": "pthread_rwlock_destroy",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native futex-backed rwlock destroy; returns EBUSY when reader/writer state is active and EINVAL for unmanaged storage",
      "hardened_semantics": "Native futex-backed rwlock destroy with deterministic managed-state validation and explicit busy-state rejection",
      "default_stub": false
    },
    {
      "symbol": "pthread_rwlock_init",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native futex-backed rwlock init with deterministic managed magic tagging and null-attr requirement",
      "hardened_semantics": "Native futex-backed rwlock init with deterministic pointer validation and explicit unsupported-attribute rejection",
      "default_stub": false
    },
    {
      "symbol": "pthread_rwlock_rdlock",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native futex-backed read lock with reader-count state machine and deterministic EINVAL for unmanaged storage",
      "hardened_semantics": "Native futex-backed read lock with deterministic state validation and bounded wait behavior",
      "default_stub": false
    },
    {
      "symbol": "pthread_rwlock_tryrdlock",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Try read lock with futex backend.",
      "hardened_semantics": "Same.",
      "default_stub": "Returns EINVAL"
    },
    {
      "symbol": "pthread_rwlock_trywrlock",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Try write lock with futex backend.",
      "hardened_semantics": "Same.",
      "default_stub": "Returns EINVAL"
    },
    {
      "symbol": "pthread_rwlock_unlock",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native futex-backed unlock for writer/reader holders; deterministic EPERM for unlocked state and EINVAL for unmanaged storage",
      "hardened_semantics": "Native futex-backed unlock with deterministic holder-state checks and wake-on-last-release behavior",
      "default_stub": false
    },
    {
      "symbol": "pthread_rwlock_wrlock",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native futex-backed write lock with exclusive writer state and deterministic EINVAL for unmanaged storage",
      "hardened_semantics": "Native futex-backed write lock with deterministic state validation and bounded wait behavior",
      "default_stub": false
    },
    {
      "symbol": "pthread_rwlockattr_destroy",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to glibc.",
      "hardened_semantics": "Same.",
      "default_stub": "Returns EINVAL"
    },
    {
      "symbol": "pthread_rwlockattr_init",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to glibc.",
      "hardened_semantics": "Same.",
      "default_stub": "Returns EINVAL"
    },
    {
      "symbol": "pthread_self",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native self id resolution: returns managed ThreadHandle-backed pthread_t when available, otherwise kernel tid fallback",
      "hardened_semantics": "Native self id resolution under membrane policy routing with deterministic managed-handle preference",
      "default_stub": false
    },
    {
      "symbol": "pthread_setcancelstate",
      "status": "GlibcCallThrough",
      "module": "pthread_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc pthread_setcancelstate",
      "hardened_semantics": "Passthrough to glibc pthread_setcancelstate",
      "default_stub": false
    },
    {
      "symbol": "pthread_setcanceltype",
      "status": "GlibcCallThrough",
      "module": "pthread_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc pthread_setcanceltype",
      "hardened_semantics": "Passthrough to glibc pthread_setcanceltype",
      "default_stub": false
    },
    {
      "symbol": "pthread_setname_np",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough",
      "hardened_semantics": "Passthrough",
      "default_stub": false
    },
    {
      "symbol": "pthread_setspecific",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Thread-specific data storage.",
      "hardened_semantics": "Same.",
      "default_stub": "Returns EINVAL"
    },
    {
      "symbol": "pthread_sigmask",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to sigprocmask; identical on Linux (rt_sigprocmask)",
      "hardened_semantics": "Delegates to sigprocmask with membrane gating",
      "default_stub": false
    },
    {
      "symbol": "pthread_spin_destroy",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough",
      "hardened_semantics": "Passthrough",
      "default_stub": false
    },
    {
      "symbol": "pthread_spin_init",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough",
      "hardened_semantics": "Passthrough",
      "default_stub": false
    },
    {
      "symbol": "pthread_spin_lock",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough",
      "hardened_semantics": "Passthrough",
      "default_stub": false
    },
    {
      "symbol": "pthread_spin_trylock",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough",
      "hardened_semantics": "Passthrough",
      "default_stub": false
    },
    {
      "symbol": "pthread_spin_unlock",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough",
      "hardened_semantics": "Passthrough",
      "default_stub": false
    },
    {
      "symbol": "pthread_testcancel",
      "status": "GlibcCallThrough",
      "module": "pthread_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc pthread_testcancel",
      "hardened_semantics": "Passthrough to glibc pthread_testcancel",
      "default_stub": false
    },
    {
      "symbol": "ptsname",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Resolves PTY slave path using ioctl(TIOCGPTN) and returns static NUL-terminated /dev/pts/<n> buffer",
      "hardened_semantics": "Same resolver; invalid/non-PTY fds map to deterministic errno and NULL return",
      "default_stub": false
    },
    {
      "symbol": "putc",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Function alias for fputc; writes one byte to stream",
      "hardened_semantics": "Same as strict; inherits fputc membrane checks",
      "default_stub": false
    },
    {
      "symbol": "putc_unlocked",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "putchar",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "putenv",
      "header": "stdlib.h",
      "status": "Implemented",
      "module": "stdlib_abi",
      "notes": ""
    },
    {
      "symbol": "puts",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native string scan with direct write to stdout fd plus trailing newline; no host glibc delegation",
      "hardened_semantics": "Native implementation; membrane bounds string scan, logs TruncateWithNull for unterminated strings",
      "default_stub": false
    },
    {
      "symbol": "putwchar",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "fast",
      "strict_semantics": "Native stdout wide-char write via fputwc over stdio sentinel stream",
      "hardened_semantics": "Same deterministic WEOF contract with UTF-8 validation"
    },
    {
      "symbol": "pwrite",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "pwrite64",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "LP64 alias to native unistd/io/mmap entrypoints (no glibc call-through)",
      "hardened_semantics": "Same alias routing with membrane behavior inherited from target entrypoints",
      "default_stub": false
    },
    {
      "symbol": "pwritev",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_pwritev \u2014 vectored pwrite",
      "hardened_semantics": "SYS_pwritev \u2014 vectored pwrite",
      "default_stub": false
    },
    {
      "symbol": "pwritev2",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_pwritev2 \u2014 vectored pwrite with flags",
      "hardened_semantics": "SYS_pwritev2 \u2014 vectored pwrite with flags",
      "default_stub": false
    },
    {
      "symbol": "qsort",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "raise",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for signal handling; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies invalid signal numbers instead of passing to kernel",
      "default_stub": false
    },
    {
      "symbol": "rand",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Thread-local LCG pseudo-random generator; glibc-compatible constants",
      "hardened_semantics": "No mode difference; pure computation",
      "default_stub": false
    },
    {
      "symbol": "rand_r",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Reentrant LCG pseudo-random generator using caller-provided state",
      "hardened_semantics": "Null seedp check; returns 0 on null",
      "default_stub": false
    },
    {
      "symbol": "read",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "readahead",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_readahead",
      "hardened_semantics": "SYS_readahead",
      "default_stub": false
    },
    {
      "symbol": "readdir",
      "status": "RawSyscall",
      "module": "dirent_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for directory enumeration; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates path pointer bounds before getdents64",
      "default_stub": false
    },
    {
      "symbol": "readdir64",
      "status": "Implemented",
      "module": "dirent_abi",
      "perf_class": "default",
      "strict_semantics": "LP64 alias via glibc",
      "hardened_semantics": "LP64 alias via glibc",
      "default_stub": false
    },
    {
      "symbol": "readdir_r",
      "status": "Implemented",
      "module": "dirent_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc readdir_r (deprecated but used)",
      "hardened_semantics": "Passthrough to glibc readdir_r (deprecated but used)",
      "default_stub": false
    },
    {
      "symbol": "readlink",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "readlinkat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "readv",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "realloc",
      "status": "Implemented",
      "module": "malloc_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust arena allocator; null on failure; double-free silently ignored",
      "hardened_semantics": "Arena with healing: foreign-ptr realloc as malloc, double-free logged as HealingAction",
      "default_stub": false
    },
    {
      "symbol": "reallocarray",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "default",
      "strict_semantics": "Overflow-checked nmemb*size then delegates to realloc semantics",
      "hardened_semantics": "Overflow-checked nmemb*size with ENOMEM on overflow; delegates to realloc path",
      "default_stub": false
    },
    {
      "symbol": "realpath",
      "header": "stdlib.h",
      "family": "unistd",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "default",
      "strict_semantics": "Native canonicalization via Rust filesystem path resolution with caller-buffer or malloc output",
      "hardened_semantics": "Same canonicalization path with runtime-policy deny/observe gating and deterministic errno",
      "default_stub": false
    },
    {
      "symbol": "recv",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "recvfrom",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "recvmmsg",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall"
    },
    {
      "symbol": "recvmsg",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for scatter/gather receive via msghdr; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates msghdr pointer",
      "default_stub": false
    },
    {
      "symbol": "regcomp",
      "status": "GlibcCallThrough",
      "module": "string_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc regcomp",
      "hardened_semantics": "Passthrough to glibc regcomp",
      "default_stub": false
    },
    {
      "symbol": "regerror",
      "status": "GlibcCallThrough",
      "module": "string_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc regerror",
      "hardened_semantics": "Passthrough to glibc regerror",
      "default_stub": false
    },
    {
      "symbol": "regexec",
      "status": "GlibcCallThrough",
      "module": "string_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc regexec",
      "hardened_semantics": "Passthrough to glibc regexec",
      "default_stub": false
    },
    {
      "symbol": "regfree",
      "status": "GlibcCallThrough",
      "module": "string_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc regfree",
      "hardened_semantics": "Passthrough to glibc regfree",
      "default_stub": false
    },
    {
      "symbol": "remainder",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; y==0 or infinite x with finite y sets errno=EDOM while preserving IEEE 754 NaN behavior",
      "hardened_semantics": "Same errno signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "remainderf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "remove",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "strict_slow",
      "strict_semantics": "Remove file via unlinkat; falls back to rmdir for directories",
      "hardened_semantics": "Same as strict with null-pointer guard",
      "default_stub": false
    },
    {
      "symbol": "removexattr",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_removexattr",
      "hardened_semantics": "SYS_removexattr",
      "default_stub": false
    },
    {
      "symbol": "rename",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "renameat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "res_init",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "res_query",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "syscall"
    },
    {
      "symbol": "res_search",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "syscall"
    },
    {
      "symbol": "rewind",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "rewinddir",
      "status": "Implemented",
      "module": "dirent_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc rewinddir",
      "hardened_semantics": "Passthrough to glibc rewinddir",
      "default_stub": false
    },
    {
      "symbol": "rindex",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Alias for strrchr",
      "hardened_semantics": "Same as strrchr hardened semantics",
      "default_stub": false
    },
    {
      "symbol": "rint",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; rounds according to current floating-point mode while preserving IEEE 754 NaN/Inf behavior",
      "hardened_semantics": "Rust libm path; no mode difference expected for finite inputs",
      "default_stub": false
    },
    {
      "symbol": "rintf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "rmdir",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "round",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "roundf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "scalbln",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "scalblnf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "scalbn",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "scalbnf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "scandir",
      "status": "Implemented",
      "module": "dirent_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc scandir",
      "hardened_semantics": "Passthrough to glibc scandir",
      "default_stub": false
    },
    {
      "symbol": "scandir64",
      "status": "Implemented",
      "module": "dirent_abi",
      "perf_class": "default",
      "strict_semantics": "LP64 alias via glibc",
      "hardened_semantics": "LP64 alias via glibc",
      "default_stub": false
    },
    {
      "symbol": "scanf",
      "status": "GlibcCallThrough",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to glibc vscanf after membrane validation.",
      "hardened_semantics": "Same delegation; format string validated by glibc.",
      "default_stub": "Returns EOF"
    },
    {
      "symbol": "sched_get_priority_max",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_sched_get_priority_max \u2014 query kernel scheduler priority ceiling for a policy",
      "hardened_semantics": "SYS_sched_get_priority_max \u2014 same query path with deterministic errno propagation",
      "default_stub": false
    },
    {
      "symbol": "sched_get_priority_min",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_sched_get_priority_min \u2014 query kernel scheduler priority floor for a policy",
      "hardened_semantics": "SYS_sched_get_priority_min \u2014 same query path with deterministic errno propagation",
      "default_stub": false
    },
    {
      "symbol": "sched_getaffinity",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_sched_getaffinity \u2014 get CPU affinity",
      "hardened_semantics": "SYS_sched_getaffinity \u2014 get CPU affinity",
      "default_stub": false
    },
    {
      "symbol": "sched_getparam",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_sched_getparam \u2014 query scheduler parameters for a process",
      "hardened_semantics": "SYS_sched_getparam \u2014 same query path with deterministic errno propagation",
      "default_stub": false
    },
    {
      "symbol": "sched_getscheduler",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_sched_getscheduler \u2014 query scheduler policy for a process",
      "hardened_semantics": "SYS_sched_getscheduler \u2014 same query path with deterministic errno propagation",
      "default_stub": false
    },
    {
      "symbol": "sched_rr_get_interval",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall",
      "strict_semantics": "SYS_sched_rr_get_interval \u2014 query round-robin timeslice interval",
      "hardened_semantics": "SYS_sched_rr_get_interval \u2014 same query path with deterministic errno propagation",
      "default_stub": false
    },
    {
      "symbol": "sched_setaffinity",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_sched_setaffinity \u2014 set CPU affinity",
      "hardened_semantics": "SYS_sched_setaffinity \u2014 set CPU affinity",
      "default_stub": false
    },
    {
      "symbol": "sched_setparam",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_sched_setparam \u2014 set scheduler parameters for a process",
      "hardened_semantics": "SYS_sched_setparam \u2014 same syscall path with deterministic errno propagation",
      "default_stub": false
    },
    {
      "symbol": "sched_setscheduler",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_sched_setscheduler \u2014 set scheduler policy/parameters for a process",
      "hardened_semantics": "SYS_sched_setscheduler \u2014 same syscall path with deterministic errno propagation",
      "default_stub": false
    },
    {
      "symbol": "sched_yield",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "secure_getenv",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "seekdir",
      "status": "Implemented",
      "module": "dirent_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc seekdir",
      "hardened_semantics": "Passthrough to glibc seekdir",
      "default_stub": false
    },
    {
      "symbol": "select",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for I/O multiplexing; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps nfds to tracked pollfd array bounds",
      "default_stub": false
    },
    {
      "symbol": "sem_close",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc sem_close",
      "hardened_semantics": "Passthrough to glibc sem_close",
      "default_stub": false
    },
    {
      "symbol": "sem_destroy",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Futex-based unnamed semaphore destroy (no-op)",
      "hardened_semantics": "Futex-based unnamed semaphore destroy (no-op)",
      "default_stub": false
    },
    {
      "symbol": "sem_getvalue",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Futex-based atomic read of semaphore counter",
      "hardened_semantics": "Futex-based atomic read of semaphore counter",
      "default_stub": false
    },
    {
      "symbol": "sem_init",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Futex-based unnamed semaphore init with atomic store",
      "hardened_semantics": "Futex-based unnamed semaphore init with atomic store",
      "default_stub": false
    },
    {
      "symbol": "sem_open",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc sem_open",
      "hardened_semantics": "Passthrough to glibc sem_open",
      "default_stub": false
    },
    {
      "symbol": "sem_post",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Futex-based atomic increment + FUTEX_WAKE",
      "hardened_semantics": "Futex-based atomic increment + FUTEX_WAKE with overflow check",
      "default_stub": false
    },
    {
      "symbol": "sem_timedwait",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Futex-based CAS decrement with FUTEX_WAIT timeout",
      "hardened_semantics": "Futex-based CAS decrement with FUTEX_WAIT timeout",
      "default_stub": false
    },
    {
      "symbol": "sem_trywait",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Futex-based non-blocking CAS decrement",
      "hardened_semantics": "Futex-based non-blocking CAS decrement",
      "default_stub": false
    },
    {
      "symbol": "sem_unlink",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc sem_unlink",
      "hardened_semantics": "Passthrough to glibc sem_unlink",
      "default_stub": false
    },
    {
      "symbol": "sem_wait",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Futex-based CAS decrement with FUTEX_WAIT blocking",
      "hardened_semantics": "Futex-based CAS decrement with FUTEX_WAIT blocking",
      "default_stub": false
    },
    {
      "symbol": "semctl",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall",
      "strict_semantics": "SYS_semctl with vararg command routing",
      "hardened_semantics": "SYS_semctl with vararg command routing",
      "default_stub": false
    },
    {
      "symbol": "semget",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall",
      "strict_semantics": "SYS_semget",
      "hardened_semantics": "SYS_semget",
      "default_stub": false
    },
    {
      "symbol": "semop",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall",
      "strict_semantics": "SYS_semop",
      "hardened_semantics": "SYS_semop",
      "default_stub": false
    },
    {
      "symbol": "send",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "sendfile",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "sendfile64",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "LP64 alias to native unistd/io/mmap entrypoints (no glibc call-through)",
      "hardened_semantics": "Same alias routing with membrane behavior inherited from target entrypoints",
      "default_stub": false
    },
    {
      "symbol": "sendmmsg",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall"
    },
    {
      "symbol": "sendmsg",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for scatter/gather send via msghdr; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates msghdr pointer",
      "default_stub": false
    },
    {
      "symbol": "sendto",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "setbuf",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "setdomainname",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall",
      "strict_semantics": "Raw Linux syscall SYS_setdomainname with POSIX errno mapping",
      "hardened_semantics": "Raw syscall with membrane policy gating and deterministic null-pointer rejection",
      "default_stub": false
    },
    {
      "symbol": "setegid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall via SYS_setregid; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; credential change operation",
      "default_stub": false
    },
    {
      "symbol": "setenv",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "seteuid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall via SYS_setreuid; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; credential change operation",
      "default_stub": false
    },
    {
      "symbol": "setgid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_setgid; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; credential change operation",
      "default_stub": false
    },
    {
      "symbol": "setgrent",
      "status": "Implemented",
      "module": "grp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: rewinds /etc/group iteration cursor",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "setgroups",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_setgroups; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; credential change operation",
      "default_stub": false
    },
    {
      "symbol": "sethostname",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall",
      "strict_semantics": "Raw Linux syscall SYS_sethostname with POSIX errno mapping",
      "hardened_semantics": "Raw syscall with membrane policy gating and deterministic null-pointer rejection",
      "default_stub": false
    },
    {
      "symbol": "setitimer",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "setjmp",
      "status": "Implemented",
      "module": "setjmp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Phase-1 capture with metadata tracking.",
      "hardened_semantics": "Same with additional validation.",
      "default_stub": "Returns -1"
    },
    {
      "symbol": "setlinebuf",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "setlocale",
      "status": "Implemented",
      "module": "locale_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Bootstrap locale implementation: setlocale supports C/POSIX and localeconv returns static C locale struct",
      "hardened_semantics": "Locale implementation with hardened fallback to C locale defaults on invalid input",
      "default_stub": false
    },
    {
      "symbol": "setmntent",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "setpgid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_setpgid; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates pid and pgid parameters",
      "default_stub": false
    },
    {
      "symbol": "setpwent",
      "status": "Implemented",
      "module": "pwd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: rewinds /etc/passwd iteration cursor",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "setregid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_setregid; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; credential change operation",
      "default_stub": false
    },
    {
      "symbol": "setreuid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_setreuid; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; credential change operation",
      "default_stub": false
    },
    {
      "symbol": "setrlimit",
      "status": "RawSyscall",
      "module": "resource_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for getrlimit/setrlimit; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies invalid resource constants",
      "default_stub": false
    },
    {
      "symbol": "setsid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_setsid; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; session creation",
      "default_stub": false
    },
    {
      "symbol": "setsockopt",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "setuid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_setuid; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; credential change operation",
      "default_stub": false
    },
    {
      "symbol": "setutent",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "setvbuf",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "setxattr",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_setxattr",
      "hardened_semantics": "SYS_setxattr",
      "default_stub": false
    },
    {
      "symbol": "shm_open",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_openat on /dev/shm/<name> mapping",
      "hardened_semantics": "SYS_openat on /dev/shm/<name> mapping with name validation",
      "default_stub": false
    },
    {
      "symbol": "shm_unlink",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_unlinkat on /dev/shm/<name> mapping",
      "hardened_semantics": "SYS_unlinkat on /dev/shm/<name> mapping with name validation",
      "default_stub": false
    },
    {
      "symbol": "shmat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall",
      "strict_semantics": "SYS_shmat",
      "hardened_semantics": "SYS_shmat",
      "default_stub": false
    },
    {
      "symbol": "shmctl",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall",
      "strict_semantics": "SYS_shmctl",
      "hardened_semantics": "SYS_shmctl",
      "default_stub": false
    },
    {
      "symbol": "shmdt",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall",
      "strict_semantics": "SYS_shmdt",
      "hardened_semantics": "SYS_shmdt",
      "default_stub": false
    },
    {
      "symbol": "shmget",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall",
      "strict_semantics": "SYS_shmget",
      "hardened_semantics": "SYS_shmget",
      "default_stub": false
    },
    {
      "symbol": "shutdown",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "sigaction",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for signal handling; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies invalid signal numbers instead of passing to kernel",
      "default_stub": false
    },
    {
      "symbol": "sigaddset",
      "status": "Implemented",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure bit manipulation on sigset_t; validates signal number, sets errno EINVAL on failure",
      "hardened_semantics": "Pure bit manipulation; validates signal number range before modification",
      "default_stub": false
    },
    {
      "symbol": "sigaltstack",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_sigaltstack; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; membrane-gated alternate signal stack management",
      "default_stub": false
    },
    {
      "symbol": "sigdelset",
      "status": "Implemented",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure bit manipulation on sigset_t; validates signal number, sets errno EINVAL on failure",
      "hardened_semantics": "Pure bit manipulation; validates signal number range before modification",
      "default_stub": false
    },
    {
      "symbol": "sigemptyset",
      "status": "Implemented",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Zeroes entire sigset_t structure; null pointer returns -1",
      "hardened_semantics": "Zeroes sigset_t; null pointer guard returns -1",
      "default_stub": false
    },
    {
      "symbol": "sigfillset",
      "status": "Implemented",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Sets all bits in sigset_t structure; null pointer returns -1",
      "hardened_semantics": "Sets all sigset_t bits; null pointer guard returns -1",
      "default_stub": false
    },
    {
      "symbol": "sigismember",
      "status": "Implemented",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure bit query on sigset_t; returns 1 if signal in set, 0 if not, -1 on invalid input",
      "hardened_semantics": "Pure bit query; validates signal number range before testing membership",
      "default_stub": false
    },
    {
      "symbol": "siglongjmp",
      "status": "Implemented",
      "module": "setjmp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "longjmp with signal mask restore metadata.",
      "hardened_semantics": "Same.",
      "default_stub": "Aborts"
    },
    {
      "symbol": "signal",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for signal handling; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies invalid signal numbers instead of passing to kernel",
      "default_stub": false
    },
    {
      "symbol": "signalfd",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_signalfd4 \u2014 signal file descriptor",
      "hardened_semantics": "SYS_signalfd4 \u2014 signal file descriptor",
      "default_stub": false
    },
    {
      "symbol": "sigpending",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc sigpending",
      "hardened_semantics": "Passthrough to glibc sigpending",
      "default_stub": false
    },
    {
      "symbol": "sigprocmask",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_rt_sigprocmask; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; membrane-gated signal mask manipulation",
      "default_stub": false
    },
    {
      "symbol": "sigqueue",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall",
      "strict_semantics": "SYS_rt_sigqueueinfo with SI_QUEUE metadata and queued payload bits",
      "hardened_semantics": "SYS_rt_sigqueueinfo with deterministic errno propagation",
      "default_stub": false
    },
    {
      "symbol": "sigsetjmp",
      "status": "Implemented",
      "module": "setjmp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "setjmp with optional signal mask save.",
      "hardened_semantics": "Same.",
      "default_stub": "Returns -1"
    },
    {
      "symbol": "sigsuspend",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_rt_sigsuspend; always returns -1 with EINTR",
      "hardened_semantics": "Raw syscall; membrane-gated signal suspension with EINTR on delivery",
      "default_stub": false
    },
    {
      "symbol": "sigtimedwait",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall",
      "strict_semantics": "SYS_rt_sigtimedwait with explicit sigset_t size argument",
      "hardened_semantics": "SYS_rt_sigtimedwait with deterministic errno propagation",
      "default_stub": false
    },
    {
      "symbol": "sigwait",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc sigwait",
      "hardened_semantics": "Passthrough to glibc sigwait",
      "default_stub": false
    },
    {
      "symbol": "sigwaitinfo",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall",
      "strict_semantics": "SYS_rt_sigtimedwait with null timeout for sigwaitinfo semantics",
      "hardened_semantics": "SYS_rt_sigtimedwait (null timeout) with deterministic errno propagation",
      "default_stub": false
    },
    {
      "symbol": "sin",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "sinf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "sinh",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; finite overflow to signed infinity sets errno=ERANGE while preserving IEEE 754 behavior",
      "hardened_semantics": "Same ERANGE overflow signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "sinhf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "sleep",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "snprintf",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native printf engine into caller-provided bounded buffer; no host glibc call-through",
      "hardened_semantics": "Native bounded formatting path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "socket",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "socketpair",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall to create a pair of connected sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates sv output pointer and address family/type arguments",
      "default_stub": false
    },
    {
      "symbol": "splice",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_splice \u2014 zero-copy pipe transfer",
      "hardened_semantics": "SYS_splice \u2014 zero-copy pipe transfer",
      "default_stub": false
    },
    {
      "symbol": "sprintf",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native printf engine into caller-provided buffer; no host glibc call-through",
      "hardened_semantics": "Native unbounded formatting path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "sqrt",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; finite x<0 sets errno=EDOM and preserves signed zero plus IEEE 754 NaN/Inf behavior",
      "hardened_semantics": "Same domain errno signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "sqrtf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "srand",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Seeds thread-local LCG generator",
      "hardened_semantics": "No mode difference; pure computation",
      "default_stub": false
    },
    {
      "symbol": "sscanf",
      "status": "GlibcCallThrough",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to glibc vsscanf after membrane validation.",
      "hardened_semantics": "Same delegation; format string validated by glibc.",
      "default_stub": "Returns EOF"
    },
    {
      "symbol": "stat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "stat64",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "LP64 alias to native unistd/io/mmap entrypoints (no glibc call-through)",
      "hardened_semantics": "Same alias routing with membrane behavior inherited from target entrypoints",
      "default_stub": false
    },
    {
      "symbol": "statx",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_statx \u2014 extended file status",
      "hardened_semantics": "SYS_statx \u2014 extended file status",
      "default_stub": false
    },
    {
      "symbol": "stderr",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "stdin",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "stdout",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "stpcpy",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "stpncpy",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strcasecmp",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust case-insensitive compare; ASCII lowering; unbounded scan; no repair",
      "hardened_semantics": "Clamps scan to tracked allocation bounds; logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strcasestr",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust case-insensitive substring search via eq_ignore_ascii_case; no repair",
      "hardened_semantics": "Clamps scan to tracked allocation bounds; logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strcat",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strchr",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strchrnul",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strcmp",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strcoll",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Delegates to strcmp in C/POSIX locale; no repair",
      "hardened_semantics": "Scans within tracked bounds; same as strcmp hardened",
      "default_stub": false
    },
    {
      "symbol": "strcpy",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strcspn",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust complement span scan; returns length of initial segment not in reject set",
      "hardened_semantics": "Clamps scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strdup",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string scan + malloc + copy; no repair; returns malloc'd duplicate",
      "hardened_semantics": "Clamps scan to tracked allocation bounds; malloc via membrane allocator",
      "default_stub": false
    },
    {
      "symbol": "strerror",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native errno-to-message mapping; returns thread-local static buffer; no host glibc",
      "hardened_semantics": "Same as strict; thread-local buffer prevents data races",
      "default_stub": false
    },
    {
      "symbol": "strerror_r",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "coldpath",
      "strict_semantics": "XSI-compliant reentrant strerror; copies message into caller buffer; returns 0 or ERANGE",
      "hardened_semantics": "Same as strict; bounded write into caller buffer",
      "default_stub": false
    },
    {
      "symbol": "strftime",
      "header": "time.h",
      "family": "time",
      "status": "Implemented",
      "notes": "Full POSIX strftime format specifier support (UTC only)"
    },
    {
      "symbol": "strlcat",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust bounded concatenation with guaranteed NUL termination; no repair",
      "hardened_semantics": "Clamps to tracked allocation bounds; logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strlcpy",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust bounded copy with guaranteed NUL termination; no repair",
      "hardened_semantics": "Clamps to tracked allocation bounds; logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strlen",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strncasecmp",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust case-insensitive compare of at most n bytes; ASCII lowering; no repair",
      "hardened_semantics": "Clamps compare span to tracked allocation bounds; logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strncat",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strncmp",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strncpy",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strndup",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; scans up to n bytes then malloc+copy; no repair",
      "hardened_semantics": "Clamps scan to tracked allocation bounds; malloc via membrane allocator",
      "default_stub": false
    },
    {
      "symbol": "strnlen",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strpbrk",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strptime",
      "status": "GlibcCallThrough",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to glibc strptime for date/time parsing.",
      "hardened_semantics": "Same delegation. Null pointers return NULL.",
      "default_stub": "Returns NULL"
    },
    {
      "symbol": "strrchr",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strsep",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust token extraction with NUL delimiter write; no repair",
      "hardened_semantics": "Scans within tracked bounds; clamps string pointer updates",
      "default_stub": false
    },
    {
      "symbol": "strsignal",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "default",
      "strict_semantics": "Native signal name lookup via static table + TLS buffer",
      "hardened_semantics": "Native signal name lookup via static table + TLS buffer",
      "default_stub": false
    },
    {
      "symbol": "strspn",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strstr",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strtod",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "String-to-double with endptr via Rust parse; supports inf/nan/hex",
      "hardened_semantics": "Membrane-validated string scan before parse",
      "default_stub": false
    },
    {
      "symbol": "strtof",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "String-to-float via strtod with narrowing cast",
      "hardened_semantics": "Same as strtod hardened semantics",
      "default_stub": false
    },
    {
      "symbol": "strtoimax",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "strtok",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strtok_r",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strtol",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "strtold",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "default",
      "strict_semantics": "Native alias to strtod path under current f64 long-double model",
      "hardened_semantics": "Native alias to strtod with runtime-policy deny/observe path",
      "default_stub": false
    },
    {
      "symbol": "strtoll",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "strtoul",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "strtoull",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "strtoumax",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "strxfrm",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Plain copy in C/POSIX locale; no repair",
      "hardened_semantics": "Clamps to tracked allocation bounds",
      "default_stub": false
    },
    {
      "symbol": "swab",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust adjacent byte pair swap; no repair",
      "hardened_semantics": "Clamps length to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "swprintf",
      "status": "GlibcCallThrough",
      "module": "wchar_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "swscanf",
      "status": "GlibcCallThrough",
      "module": "wchar_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "symlink",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "symlinkat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "sync",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_sync",
      "hardened_semantics": "SYS_sync",
      "default_stub": false
    },
    {
      "symbol": "syncfs",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_syncfs",
      "hardened_semantics": "SYS_syncfs",
      "default_stub": false
    },
    {
      "symbol": "sysconf",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "native",
      "semantics": "POSIX"
    },
    {
      "symbol": "syslog",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Variadic forwarded via vsyslog to glibc",
      "hardened_semantics": "Variadic forwarded via vsyslog to glibc",
      "default_stub": false
    },
    {
      "symbol": "system",
      "header": "stdlib.h",
      "status": "Implemented",
      "module": "stdlib_abi",
      "notes": ""
    },
    {
      "symbol": "tan",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "tanf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "tanh",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; bounded odd hyperbolic tangent over finite domain; no errno side effects",
      "hardened_semantics": "Rust std::f64 math; no mode difference expected for finite inputs",
      "default_stub": false
    },
    {
      "symbol": "tanhf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "tcdrain",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "tcflow",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "tcflush",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "tcgetattr",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "tcsendbreak",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "tcsetattr",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "tee",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_tee \u2014 duplicate pipe content",
      "hardened_semantics": "SYS_tee \u2014 duplicate pipe content",
      "default_stub": false
    },
    {
      "symbol": "telldir",
      "status": "Implemented",
      "module": "dirent_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc telldir",
      "hardened_semantics": "Passthrough to glibc telldir",
      "default_stub": false
    },
    {
      "symbol": "textdomain",
      "status": "Implemented",
      "module": "locale_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc textdomain",
      "hardened_semantics": "Passthrough to glibc textdomain",
      "default_stub": false
    },
    {
      "symbol": "tgamma",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; negative integer poles set errno=EDOM, zero/pole-overflow/underflow regimes set errno=ERANGE",
      "hardened_semantics": "Same errno signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "tgammaf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "time",
      "status": "RawSyscall",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for time queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; defaults invalid clock_id to CLOCK_REALTIME",
      "default_stub": false
    },
    {
      "symbol": "timegm",
      "status": "Implemented",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to mktime; pure Rust broken_down_to_epoch; UTC",
      "hardened_semantics": "Delegates to mktime with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "timer_create",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall",
      "strict_semantics": "SYS_timer_create \u2014 create POSIX per-process timer using kernel timer id output",
      "hardened_semantics": "SYS_timer_create \u2014 same syscall path with deterministic errno propagation",
      "default_stub": false
    },
    {
      "symbol": "timer_delete",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall",
      "strict_semantics": "SYS_timer_delete \u2014 delete POSIX per-process timer by kernel timer id",
      "hardened_semantics": "SYS_timer_delete \u2014 same syscall path with deterministic errno propagation",
      "default_stub": false
    },
    {
      "symbol": "timer_getoverrun",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall",
      "strict_semantics": "SYS_timer_getoverrun \u2014 fetch timer overrun count from kernel timer id",
      "hardened_semantics": "SYS_timer_getoverrun \u2014 same syscall path with deterministic errno propagation",
      "default_stub": false
    },
    {
      "symbol": "timer_gettime",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall",
      "strict_semantics": "SYS_timer_gettime \u2014 read timer expiration state into itimerspec",
      "hardened_semantics": "SYS_timer_gettime \u2014 same syscall path with deterministic errno propagation",
      "default_stub": false
    },
    {
      "symbol": "timer_settime",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall",
      "strict_semantics": "SYS_timer_settime \u2014 arm/disarm timer using itimerspec payload",
      "hardened_semantics": "SYS_timer_settime \u2014 same syscall path with deterministic errno propagation",
      "default_stub": false
    },
    {
      "symbol": "timerfd_create",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "timerfd_gettime",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "timerfd_settime",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "tmpfile",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "strict_slow",
      "strict_semantics": "Create temporary file via O_TMPFILE with fallback to mkstemp+unlink",
      "hardened_semantics": "Same as strict; auto-deleted on close",
      "default_stub": false
    },
    {
      "symbol": "tmpfile64",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "default",
      "strict_semantics": "LP64 alias to native tmpfile implementation",
      "hardened_semantics": "LP64 alias to native tmpfile implementation",
      "default_stub": false
    },
    {
      "symbol": "tmpnam",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "strict_fast",
      "strict_semantics": "Generate unique temp filename using pid+counter",
      "hardened_semantics": "Same as strict; thread-safe with atomic counter",
      "default_stub": false
    },
    {
      "symbol": "toascii",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "trivial",
      "strict_semantics": "pass-through",
      "hardened_semantics": "pass-through",
      "default_stub": false
    },
    {
      "symbol": "tolower",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "toupper",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "towlower",
      "header": "wctype.h",
      "family": "wctype",
      "status": "Implemented",
      "notes": "Wide character to lowercase"
    },
    {
      "symbol": "towupper",
      "header": "wctype.h",
      "family": "wctype",
      "status": "Implemented",
      "notes": "Wide character to uppercase"
    },
    {
      "symbol": "trunc",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; rounds toward zero while preserving IEEE 754 NaN/Inf behavior",
      "hardened_semantics": "Rust libm path; no mode difference expected for finite inputs",
      "default_stub": false
    },
    {
      "symbol": "truncate",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "truncate64",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "LP64 alias to native unistd/io/mmap entrypoints (no glibc call-through)",
      "hardened_semantics": "Same alias routing with membrane behavior inherited from target entrypoints",
      "default_stub": false
    },
    {
      "symbol": "truncf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "ttyname",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Validates fd/terminal state and resolves tty path via /proc/self/fd/<fd>; returns static buffer pointer with errno on failure",
      "hardened_semantics": "Same as strict with runtime-policy observation and deterministic errno mapping",
      "default_stub": false
    },
    {
      "symbol": "ttyname_r",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Reentrant tty path resolution into caller buffer; returns EINVAL/EBADF/ENOTTY/ERANGE error codes",
      "hardened_semantics": "Same as strict with runtime-policy observation and deterministic error-code returns",
      "default_stub": false
    },
    {
      "symbol": "tzset",
      "status": "Implemented",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to glibc tzset for timezone initialization.",
      "hardened_semantics": "Same delegation.",
      "default_stub": "No-op"
    },
    {
      "symbol": "umask",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "uname",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "ungetc",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "ungetwc",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "fast",
      "strict_semantics": "Native UTF-8 pushback path built on stdio ungetc",
      "hardened_semantics": "Same pushback contract with deterministic EILSEQ/WEOF behavior"
    },
    {
      "symbol": "unlink",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "unlinkat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "unlockpt",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Clears PTY slave lock via ioctl(TIOCSPTLCK, 0); returns 0 or -1 with POSIX errno",
      "hardened_semantics": "Same ioctl lock-clear path with deterministic errno propagation",
      "default_stub": false
    },
    {
      "symbol": "unsetenv",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "usleep",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "utmpname",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "vasprintf",
      "header": "stdio.h",
      "family": "stdio",
      "status": "GlibcCallThrough",
      "notes": "Delegates to libc (va_list forwarding requires C ABI)"
    },
    {
      "symbol": "vdprintf",
      "header": "stdio.h",
      "family": "stdio",
      "status": "GlibcCallThrough",
      "notes": "Delegates to libc (va_list forwarding requires C ABI)"
    },
    {
      "symbol": "vfork",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to fork; identical on modern Linux",
      "hardened_semantics": "Delegates to fork with membrane gating",
      "default_stub": false
    },
    {
      "symbol": "vfprintf",
      "header": "stdio.h",
      "family": "stdio",
      "status": "GlibcCallThrough",
      "notes": "Delegates to libc (va_list forwarding requires C ABI)"
    },
    {
      "symbol": "vfscanf",
      "status": "GlibcCallThrough",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to glibc vfscanf with va_list passthrough.",
      "hardened_semantics": "Same delegation.",
      "default_stub": "Returns EOF"
    },
    {
      "symbol": "vfwprintf",
      "status": "GlibcCallThrough",
      "module": "wchar_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "vfwscanf",
      "status": "GlibcCallThrough",
      "module": "wchar_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "vmsplice",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "default",
      "strict_semantics": "SYS_vmsplice \u2014 splice user pages into pipe",
      "hardened_semantics": "SYS_vmsplice \u2014 splice user pages into pipe",
      "default_stub": false
    },
    {
      "symbol": "vprintf",
      "header": "stdio.h",
      "family": "stdio",
      "status": "GlibcCallThrough",
      "notes": "Delegates to libc (va_list forwarding requires C ABI)"
    },
    {
      "symbol": "vscanf",
      "status": "GlibcCallThrough",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to glibc vscanf with va_list passthrough.",
      "hardened_semantics": "Same delegation.",
      "default_stub": "Returns EOF"
    },
    {
      "symbol": "vsnprintf",
      "header": "stdio.h",
      "family": "stdio",
      "status": "GlibcCallThrough",
      "notes": "Delegates to libc (va_list forwarding requires C ABI)"
    },
    {
      "symbol": "vsprintf",
      "header": "stdio.h",
      "family": "stdio",
      "status": "GlibcCallThrough",
      "notes": "Delegates to libc (va_list forwarding requires C ABI)"
    },
    {
      "symbol": "vsscanf",
      "status": "GlibcCallThrough",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to glibc vsscanf with va_list passthrough.",
      "hardened_semantics": "Same delegation.",
      "default_stub": "Returns EOF"
    },
    {
      "symbol": "vswprintf",
      "status": "GlibcCallThrough",
      "module": "wchar_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "vswscanf",
      "status": "GlibcCallThrough",
      "module": "wchar_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "vsyslog",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc vsyslog",
      "hardened_semantics": "Passthrough to glibc vsyslog",
      "default_stub": false
    },
    {
      "symbol": "vwprintf",
      "status": "GlibcCallThrough",
      "module": "wchar_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "vwscanf",
      "status": "GlibcCallThrough",
      "module": "wchar_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "wait",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for process control; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates argv/envp pointer arrays before execve",
      "default_stub": false
    },
    {
      "symbol": "wait3",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to wait4(-1, ...); BSD-style wait with rusage",
      "hardened_semantics": "Delegates to wait4 with membrane gating",
      "default_stub": false
    },
    {
      "symbol": "wait4",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_wait4; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates options in hardened mode",
      "default_stub": false
    },
    {
      "symbol": "waitid",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_waitid; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates idtype and options",
      "default_stub": false
    },
    {
      "symbol": "waitpid",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for process control; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates argv/envp pointer arrays before execve",
      "default_stub": false
    },
    {
      "symbol": "wcrtomb",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Stateless UTF-8 wide-char encode with EILSEQ on invalid code points",
      "hardened_semantics": "Same encode semantics with deterministic EILSEQ and no host call-through",
      "default_stub": false
    },
    {
      "symbol": "wcscat",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcschr",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcscmp",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcscoll",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "fast",
      "strict_semantics": "C-locale wide collation using native wide-string comparison",
      "hardened_semantics": "Same deterministic comparison contract with no host libc dependency"
    },
    {
      "symbol": "wcscpy",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcscspn",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "bounds-check-and-repair",
      "default_stub": false
    },
    {
      "symbol": "wcsdup",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "bounds-check-and-repair",
      "default_stub": false
    },
    {
      "symbol": "wcsftime",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "fast",
      "strict_semantics": "Native wide-format strftime bridge via UTF-8 projection and wide-output reconstitution",
      "hardened_semantics": "Same bridge contract with deterministic EILSEQ on invalid multibyte/wide conversion"
    },
    {
      "symbol": "wcslen",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcsncat",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "bounds-check-and-repair",
      "default_stub": false
    },
    {
      "symbol": "wcsncmp",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcsncpy",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcsnlen",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Bounded wide-string length scan in Rust with runtime policy gate",
      "hardened_semantics": "Bounded scan with allocation-aware clamp/repair when tracked extent is shorter than requested bound",
      "default_stub": false
    },
    {
      "symbol": "wcspbrk",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "bounds-check-and-repair",
      "default_stub": false
    },
    {
      "symbol": "wcsrchr",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcsrtombs",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Stateless wide-string to UTF-8 multibyte conversion with source-pointer progress contract",
      "hardened_semantics": "Same conversion with deterministic EILSEQ on invalid wide code points and bounded destination writes",
      "default_stub": false
    },
    {
      "symbol": "wcsspn",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "bounds-check-and-repair",
      "default_stub": false
    },
    {
      "symbol": "wcsstr",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcstod",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "default",
      "strict_semantics": "Native wide-string floating parse via deterministic ASCII projection and endptr progression",
      "hardened_semantics": "Same conversion contract with deterministic pointer progression and no host libc dependency",
      "default_stub": false
    },
    {
      "symbol": "wcstof",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "wcstok",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "bounds-check-and-repair",
      "default_stub": false
    },
    {
      "symbol": "wcstol",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "default",
      "strict_semantics": "Native wide-string signed integer parse with base autodetect and endptr progression",
      "hardened_semantics": "Same parse contract with deterministic errno for invalid base and range overflow",
      "default_stub": false
    },
    {
      "symbol": "wcstold",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "wcstoll",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "wcstombs",
      "header": "stdlib.h",
      "family": "wchar",
      "status": "Implemented",
      "notes": "Wide string to UTF-8 multibyte string"
    },
    {
      "symbol": "wcstoul",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "default",
      "strict_semantics": "Native wide-string unsigned integer parse with base autodetect and endptr progression",
      "hardened_semantics": "Same parse contract with deterministic errno for invalid base and range overflow",
      "default_stub": false
    },
    {
      "symbol": "wcstoull",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "wcswidth",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Rust display-width accumulation over bounded wide input using wcwidth kernel",
      "hardened_semantics": "Same width accumulation with bounded scan + membrane-aware length clamping",
      "default_stub": false
    },
    {
      "symbol": "wcsxfrm",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "fast",
      "strict_semantics": "C-locale wide transform as bounded copy returning source logical length",
      "hardened_semantics": "Same transform contract with deterministic truncation via caller-provided bound"
    },
    {
      "symbol": "wctob",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "ASCII-only wide-char to single-byte conversion (UTF-8 locale contract); non-ASCII returns EOF",
      "hardened_semantics": "Same conversion with deterministic EOF on invalid inputs",
      "default_stub": false
    },
    {
      "symbol": "wctomb",
      "header": "stdlib.h",
      "family": "wchar",
      "status": "Implemented",
      "notes": "Wide character to UTF-8 multibyte"
    },
    {
      "symbol": "wcwidth",
      "header": "wchar.h",
      "family": "wchar",
      "status": "Implemented",
      "notes": "Wide character display width"
    },
    {
      "symbol": "wmemchr",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wmemcmp",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wmemcpy",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wmemmove",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wmemset",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wordexp",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc wordexp",
      "hardened_semantics": "Passthrough to glibc wordexp",
      "default_stub": false
    },
    {
      "symbol": "wordfree",
      "status": "GlibcCallThrough",
      "module": "unistd_abi",
      "perf_class": "default",
      "strict_semantics": "Passthrough to glibc wordfree",
      "hardened_semantics": "Passthrough to glibc wordfree",
      "default_stub": false
    },
    {
      "symbol": "wprintf",
      "status": "GlibcCallThrough",
      "module": "wchar_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "write",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "writev",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "wscanf",
      "status": "GlibcCallThrough",
      "module": "wchar_abi",
      "perf_class": "fast"
    },
    {
      "symbol": "setns",
      "header": "<unistd.h>",
      "status": "RawSyscall",
      "notes": "Tier 10"
    },
    {
      "symbol": "unshare",
      "header": "<unistd.h>",
      "status": "RawSyscall",
      "notes": "Tier 10"
    },
    {
      "symbol": "mount",
      "header": "<unistd.h>",
      "status": "RawSyscall",
      "notes": "Tier 10"
    },
    {
      "symbol": "umount2",
      "header": "<unistd.h>",
      "status": "RawSyscall",
      "notes": "Tier 10"
    },
    {
      "symbol": "chroot",
      "header": "<unistd.h>",
      "status": "RawSyscall",
      "notes": "Tier 10"
    },
    {
      "symbol": "pivot_root",
      "header": "<unistd.h>",
      "status": "RawSyscall",
      "notes": "Tier 10"
    },
    {
      "symbol": "acct",
      "header": "<unistd.h>",
      "status": "RawSyscall",
      "notes": "Tier 10"
    },
    {
      "symbol": "reboot",
      "header": "<unistd.h>",
      "status": "RawSyscall",
      "notes": "Tier 10"
    },
    {
      "symbol": "swapon",
      "header": "<unistd.h>",
      "status": "RawSyscall",
      "notes": "Tier 10"
    },
    {
      "symbol": "swapoff",
      "header": "<unistd.h>",
      "status": "RawSyscall",
      "notes": "Tier 10"
    },
    {
      "symbol": "getresuid",
      "header": "<unistd.h>",
      "status": "RawSyscall",
      "notes": "Tier 10"
    },
    {
      "symbol": "getresgid",
      "header": "<unistd.h>",
      "status": "RawSyscall",
      "notes": "Tier 10"
    },
    {
      "symbol": "setresuid",
      "header": "<unistd.h>",
      "status": "RawSyscall",
      "notes": "Tier 10"
    },
    {
      "symbol": "setresgid",
      "header": "<unistd.h>",
      "status": "RawSyscall",
      "notes": "Tier 10"
    },
    {
      "symbol": "fanotify_init",
      "header": "<unistd.h>",
      "status": "RawSyscall",
      "notes": "Tier 10"
    },
    {
      "symbol": "fanotify_mark",
      "header": "<unistd.h>",
      "status": "RawSyscall",
      "notes": "Tier 10"
    },
    {
      "symbol": "process_vm_readv",
      "header": "<unistd.h>",
      "status": "RawSyscall",
      "notes": "Tier 10"
    },
    {
      "symbol": "process_vm_writev",
      "header": "<unistd.h>",
      "status": "RawSyscall",
      "notes": "Tier 10"
    },
    {
      "symbol": "mlock2",
      "header": "<unistd.h>",
      "status": "RawSyscall",
      "notes": "Tier 10"
    },
    {
      "symbol": "name_to_handle_at",
      "header": "<unistd.h>",
      "status": "RawSyscall",
      "notes": "Tier 10"
    },
    {
      "symbol": "open_by_handle_at",
      "header": "<unistd.h>",
      "status": "RawSyscall",
      "notes": "Tier 10"
    },
    {
      "symbol": "umount",
      "header": "<unistd.h>",
      "status": "RawSyscall",
      "notes": "Native SYS_umount2 raw syscall"
    },
    {
      "symbol": "glob64",
      "header": "<unistd.h>",
      "status": "GlibcCallThrough",
      "notes": "Tier 10"
    },
    {
      "symbol": "globfree64",
      "header": "<unistd.h>",
      "status": "GlibcCallThrough",
      "notes": "Tier 10"
    },
    {
      "symbol": "nftw64",
      "header": "<unistd.h>",
      "status": "GlibcCallThrough",
      "notes": "Tier 10"
    },
    {
      "symbol": "alphasort64",
      "header": "<unistd.h>",
      "status": "Implemented",
      "notes": "Delegates to native alphasort (64-bit Linux alias)"
    }
  ],
  "summary": {
    "total_exported": 929,
    "implemented": 539,
    "raw_syscall": 297,
    "glibc_call_through": 93,
    "stub": 0
  },
  "implemented": 507,
  "raw_syscall": 280,
  "glibc_call_through": 142,
  "stub": 0
}
