{
  "version": 2,
  "generated_at_utc": "2026-02-18T04:49:26Z",
  "library": "/data/tmp/cargo-target/release/libfrankenlibc_abi.so",
  "total_exported": 548,
  "taxonomy": {
    "Implemented": "Native Rust code owns the entire operation. No host libc dependency. Full test coverage required.",
    "RawSyscall": "ABI entrypoint marshals arguments directly to Linux syscall instruction. No glibc call-through.",
    "GlibcCallThrough": "Delegates to host glibc after membrane pre/post validation. Requires host libc at runtime.",
    "Stub": "Deterministic failure contract. Returns stable errno/error code. Documented in support policy.",
    "perf_classes": {
      "strict_hotpath": "Called >= 1M/sec in typical workloads. Must meet <20ns strict budget.",
      "hardened_hotpath": "Called >= 1M/sec in hardened mode. Must meet <200ns hardened budget.",
      "coldpath": "Called < 1K/sec. No latency budget enforced."
    },
    "default_policy": "Any exported symbol absent from explicit classification defaults to Stub and causes drift failure (exit 3).",
    "mode_contract": {
      "strict": "POSIX-correct error semantics. Membrane validates but never silently rewrites. ABI-compatible.",
      "hardened": "TSM repair enabled. Membrane applies deterministic healing (clamp, truncate, safe-default). Logs HealingAction."
    },
    "artifact_applicability": {
      "Interpose": [
        "Implemented",
        "RawSyscall",
        "GlibcCallThrough",
        "Stub"
      ],
      "Replace": [
        "Implemented",
        "RawSyscall"
      ],
      "rule": "Implemented+RawSyscall apply to both artifacts; GlibcCallThrough+Stub are Interpose-only."
    }
  },
  "symbols": [
    {
      "symbol": "__errno_location",
      "status": "Implemented",
      "module": "errno_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Thread-local errno via Rust; ABI-compatible __errno_location pointer",
      "hardened_semantics": "Thread-local errno; no mode difference (stateless query)",
      "default_stub": false
    },
    {
      "symbol": "__frankenlibc_startup_phase0",
      "status": "Implemented",
      "module": "startup_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Phase-0 startup skeleton for controlled fixtures; validates argc/argv/envp and captures auxv/secure-mode invariants",
      "hardened_semantics": "Phase-0 startup with hardened membrane routing; deterministic startup invariant capture for fixture binaries",
      "default_stub": false
    },
    {
      "symbol": "__frankenlibc_startup_snapshot",
      "status": "Implemented",
      "module": "startup_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Phase-0 startup skeleton for controlled fixtures; validates argc/argv/envp and captures auxv/secure-mode invariants",
      "hardened_semantics": "Phase-0 startup with hardened membrane routing; deterministic startup invariant capture for fixture binaries",
      "default_stub": false
    },
    {
      "symbol": "__libc_start_main",
      "status": "Implemented",
      "module": "startup_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Phase-0 startup skeleton for controlled fixtures; validates argc/argv/envp and captures auxv/secure-mode invariants",
      "hardened_semantics": "Phase-0 startup with hardened membrane routing; deterministic startup invariant capture for fixture binaries",
      "default_stub": false
    },
    {
      "symbol": "_exit",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for process control; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates argv/envp pointer arrays before execve",
      "default_stub": false
    },
    {
      "symbol": "abs",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Integer absolute value via wrapping_abs",
      "hardened_semantics": "No mode difference; pure computation",
      "default_stub": false
    },
    {
      "symbol": "accept",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "accept4",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; accept with flags (SOCK_NONBLOCK, SOCK_CLOEXEC); POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates fd and flag arguments",
      "default_stub": false
    },
    {
      "symbol": "access",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "acos",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; finite |x|>1 sets errno=EDOM and preserves IEEE 754 NaN/Inf behavior",
      "hardened_semantics": "Same domain errno signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "acosf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "acosh",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; finite x<1 sets errno=EDOM and preserves IEEE 754 NaN/Inf behavior",
      "hardened_semantics": "Same domain errno signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "alarm",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "aligned_alloc",
      "status": "Implemented",
      "module": "malloc_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust arena allocator; null on failure; double-free silently ignored",
      "hardened_semantics": "Arena with healing: foreign-ptr realloc as malloc, double-free logged as HealingAction",
      "default_stub": false
    },
    {
      "symbol": "asctime_r",
      "status": "Implemented",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure Rust formatting of broken-down time to string; no syscall",
      "hardened_semantics": "Pure Rust formatting with null pointer guard",
      "default_stub": false
    },
    {
      "symbol": "asin",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; finite |x|>1 sets errno=EDOM and preserves IEEE 754 NaN/Inf behavior",
      "hardened_semantics": "Same domain errno signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "asinf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "asinh",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; odd inverse-hyperbolic function over finite domain; no errno side effects",
      "hardened_semantics": "Rust std::f64 math; no mode difference expected for finite inputs",
      "default_stub": false
    },
    {
      "symbol": "asprintf",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native formatted allocation using frankenlibc printf renderer and malloc-compatible output contract",
      "hardened_semantics": "Native formatted allocation with runtime-policy mediation; denial/alloc-failure returns deterministic error",
      "default_stub": false
    },
    {
      "symbol": "atan",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "atan2",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "atan2f",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "atanf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "atanh",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; finite |x|>1 sets errno=EDOM and |x|==1 sets errno=ERANGE with IEEE 754 outputs preserved",
      "hardened_semantics": "Same errno domain/range signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "atexit",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "atof",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "String-to-double conversion via Rust parse; POSIX-correct",
      "hardened_semantics": "Membrane-validated string scan before parse",
      "default_stub": false
    },
    {
      "symbol": "atoi",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "atol",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "atoll",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "bcmp",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust byte comparison; returns 0 or 1",
      "hardened_semantics": "Clamps length to tracked allocation bounds",
      "default_stub": false
    },
    {
      "symbol": "bcopy",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Delegates to memmove with swapped argument order",
      "hardened_semantics": "Same as memmove hardened semantics",
      "default_stub": false
    },
    {
      "symbol": "bind",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "bsearch",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "bzero",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust zeroing with black_box anti-optimization; no repair",
      "hardened_semantics": "Clamps length to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "calloc",
      "status": "Implemented",
      "module": "malloc_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust arena allocator; null on failure; double-free silently ignored",
      "hardened_semantics": "Arena with healing: foreign-ptr realloc as malloc, double-free logged as HealingAction",
      "default_stub": false
    },
    {
      "symbol": "cbrt",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; odd real-root function over all finite inputs, preserving signed zero and IEEE 754 NaN/Inf behavior",
      "hardened_semantics": "Rust libm path; no mode difference expected for finite inputs",
      "default_stub": false
    },
    {
      "symbol": "ceil",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "ceilf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "cfgetispeed",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "cfgetospeed",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "cfsetispeed",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "cfsetospeed",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "chdir",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "chmod",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "chown",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "clearerr",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "clock",
      "status": "RawSyscall",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for time queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; defaults invalid clock_id to CLOCK_REALTIME",
      "default_stub": false
    },
    {
      "symbol": "clock_getres",
      "status": "RawSyscall",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_clock_getres; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates clock_id before calling kernel",
      "default_stub": false
    },
    {
      "symbol": "clock_gettime",
      "status": "RawSyscall",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for time queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; defaults invalid clock_id to CLOCK_REALTIME",
      "default_stub": false
    },
    {
      "symbol": "clock_nanosleep",
      "status": "RawSyscall",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_clock_nanosleep; returns error code directly",
      "hardened_semantics": "Raw syscall; validates clock_id and req pointer",
      "default_stub": false
    },
    {
      "symbol": "close",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "closedir",
      "status": "RawSyscall",
      "module": "dirent_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for directory enumeration; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates path pointer bounds before getdents64",
      "default_stub": false
    },
    {
      "symbol": "connect",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "copysign",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; magnitude/sign transfer preserves IEEE 754 NaN payload and signed zero semantics with no errno side effects",
      "hardened_semantics": "Rust libm path; no mode difference expected for finite inputs",
      "default_stub": false
    },
    {
      "symbol": "cos",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "cosf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "cosh",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; finite overflow to infinity sets errno=ERANGE while preserving IEEE 754 behavior",
      "hardened_semantics": "Same ERANGE overflow signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "creat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "ctime_r",
      "status": "Implemented",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Combines epoch_to_broken_down with format_asctime; pure Rust",
      "hardened_semantics": "Pure Rust conversion with null pointer guard",
      "default_stub": false
    },
    {
      "symbol": "difftime",
      "status": "Implemented",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure computation returning time1 - time0 as f64; no syscall",
      "hardened_semantics": "Pure computation; no mode difference",
      "default_stub": false
    },
    {
      "symbol": "div",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Integer division returning quotient and remainder; zero-denom returns zero",
      "hardened_semantics": "No mode difference; pure computation",
      "default_stub": false
    },
    {
      "symbol": "dlclose",
      "status": "GlibcCallThrough",
      "module": "dlfcn_abi",
      "perf_class": "coldpath",
      "strict_semantics": "dlfcn boundary policy: host glibc call-through for dlopen/dlsym/dlclose with thread-local dlerror contract",
      "hardened_semantics": "dlfcn boundary policy: invalid dlopen flags heal to RTLD_NOW; null/denied loader inputs return deterministic dlerror",
      "default_stub": false
    },
    {
      "symbol": "dlerror",
      "status": "GlibcCallThrough",
      "module": "dlfcn_abi",
      "perf_class": "coldpath",
      "strict_semantics": "dlfcn boundary policy: host glibc call-through for dlopen/dlsym/dlclose with thread-local dlerror contract",
      "hardened_semantics": "dlfcn boundary policy: invalid dlopen flags heal to RTLD_NOW; null/denied loader inputs return deterministic dlerror",
      "default_stub": false
    },
    {
      "symbol": "dlopen",
      "status": "GlibcCallThrough",
      "module": "dlfcn_abi",
      "perf_class": "coldpath",
      "strict_semantics": "dlfcn boundary policy: host glibc call-through for dlopen/dlsym/dlclose with thread-local dlerror contract",
      "hardened_semantics": "dlfcn boundary policy: invalid dlopen flags heal to RTLD_NOW; null/denied loader inputs return deterministic dlerror",
      "default_stub": false
    },
    {
      "symbol": "dlsym",
      "status": "GlibcCallThrough",
      "module": "dlfcn_abi",
      "perf_class": "coldpath",
      "strict_semantics": "dlfcn boundary policy: host glibc call-through for dlopen/dlsym/dlclose with thread-local dlerror contract",
      "hardened_semantics": "dlfcn boundary policy: invalid dlopen flags heal to RTLD_NOW; null/denied loader inputs return deterministic dlerror",
      "default_stub": false
    },
    {
      "symbol": "dprintf",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native formatted write to provided fd using frankenlibc printf renderer with POSIX return-length contract",
      "hardened_semantics": "Native formatted fd write with runtime-policy mediation; denied or short writes return deterministic failure",
      "default_stub": false
    },
    {
      "symbol": "dup",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for dup/dup2/pipe/fcntl; POSIX errno on failure",
      "hardened_semantics": "Raw syscall with hardened membrane; repair on invalid flags",
      "default_stub": false
    },
    {
      "symbol": "dup2",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for dup/dup2/pipe/fcntl; POSIX errno on failure",
      "hardened_semantics": "Raw syscall with hardened membrane; repair on invalid flags",
      "default_stub": false
    },
    {
      "symbol": "dup3",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "endgrent",
      "status": "Implemented",
      "module": "grp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: closes /etc/group enumeration and frees cached data",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "endpwent",
      "status": "Implemented",
      "module": "pwd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: closes /etc/passwd enumeration and frees cached data",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "epoll_create",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "epoll_create1",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "epoll_ctl",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "epoll_pwait",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "epoll_wait",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "erf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "erfc",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "eventfd",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "execve",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for process control; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates argv/envp pointer arrays before execve",
      "default_stub": false
    },
    {
      "symbol": "execvp",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for process control; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates argv/envp pointer arrays before execve",
      "default_stub": false
    },
    {
      "symbol": "exit",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "exp",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; finite overflow/underflow routes set errno=ERANGE while preserving IEEE 754 infinities/zeros",
      "hardened_semantics": "Same ERANGE signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "exp2",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; finite overflow/underflow routes set errno=ERANGE while preserving IEEE 754 infinities/zeros",
      "hardened_semantics": "Same ERANGE signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "expf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "explicit_bzero",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Delegates to bzero with black_box guarantee",
      "hardened_semantics": "Same as bzero hardened semantics",
      "default_stub": false
    },
    {
      "symbol": "expm1",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; finite overflow to infinity sets errno=ERANGE while preserving precise near-zero behavior",
      "hardened_semantics": "Same ERANGE overflow signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "fabs",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "fabsf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "faccessat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "fchdir",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "fchmod",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "fchmodat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "fchown",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "fchownat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "fclose",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "fcntl",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for dup/dup2/pipe/fcntl; POSIX errno on failure",
      "hardened_semantics": "Raw syscall with hardened membrane; repair on invalid flags",
      "default_stub": false
    },
    {
      "symbol": "fdatasync",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "fdim",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "feof",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "ferror",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "fflush",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "ffs",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Find first set bit via trailing_zeros; returns 0 for input 0",
      "hardened_semantics": "No mode difference; pure computation",
      "default_stub": false
    },
    {
      "symbol": "ffsl",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Find first set bit in long via trailing_zeros",
      "hardened_semantics": "No mode difference; pure computation",
      "default_stub": false
    },
    {
      "symbol": "ffsll",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Find first set bit in long long via trailing_zeros",
      "hardened_semantics": "No mode difference; pure computation",
      "default_stub": false
    },
    {
      "symbol": "fgetc",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "fgets",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "fileno",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "flock",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "BSD"
    },
    {
      "symbol": "floor",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "floorf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "fma",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "fmax",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "fmin",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "fmod",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; y==0 or infinite x with finite y sets errno=EDOM while preserving IEEE 754 NaN behavior",
      "hardened_semantics": "Same errno signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "fmodf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "fopen",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "fork",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for process control; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates argv/envp pointer arrays before execve",
      "default_stub": false
    },
    {
      "symbol": "fprintf",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native printf engine + stream-registry stdio path; no host glibc call-through",
      "hardened_semantics": "Native printf engine + stream-registry stdio with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "fputc",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "fputs",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "fread",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "free",
      "status": "Implemented",
      "module": "malloc_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust arena allocator; null on failure; double-free silently ignored",
      "hardened_semantics": "Arena with healing: foreign-ptr realloc as malloc, double-free logged as HealingAction",
      "default_stub": false
    },
    {
      "symbol": "freeaddrinfo",
      "status": "Implemented",
      "module": "resolv_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Bootstrap resolver implementation: numeric getaddrinfo/getnameinfo + gai_strerror/freeaddrinfo with deterministic EAI_* failures",
      "hardened_semantics": "Resolver with deterministic repairs: invalid host/service normalized to safe defaults, evidence emitted",
      "default_stub": false
    },
    {
      "symbol": "frexp",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "fseek",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream registry with SYS_lseek syscall; flushes pending writes, discards read buffer, updates logical offset",
      "hardened_semantics": "Native implementation; membrane validates stream ID, sets EINVAL on invalid whence; heals invalid offsets via safe default",
      "default_stub": false
    },
    {
      "symbol": "fstat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "fstatat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "fsync",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "ftell",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Returns logical file offset from internal StdioStream state; no host glibc delegation",
      "hardened_semantics": "Native implementation; membrane validates stream ID, returns -1 with EBADF for invalid streams",
      "default_stub": false
    },
    {
      "symbol": "ftruncate",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "fwrite",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "gai_strerror",
      "status": "Implemented",
      "module": "resolv_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Bootstrap resolver implementation: numeric getaddrinfo/getnameinfo + gai_strerror/freeaddrinfo with deterministic EAI_* failures",
      "hardened_semantics": "Resolver with deterministic repairs: invalid host/service normalized to safe defaults, evidence emitted",
      "default_stub": false
    },
    {
      "symbol": "getaddrinfo",
      "status": "Implemented",
      "module": "resolv_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Bootstrap resolver implementation: numeric getaddrinfo/getnameinfo + gai_strerror/freeaddrinfo with deterministic EAI_* failures",
      "hardened_semantics": "Resolver with deterministic repairs: invalid host/service normalized to safe defaults, evidence emitted",
      "default_stub": false
    },
    {
      "symbol": "getchar",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "getcwd",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "getegid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "getenv",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "geteuid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "getgid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "getgrent",
      "status": "Implemented",
      "module": "grp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: iterates /etc/group entries sequentially",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getgrgid",
      "status": "Implemented",
      "module": "grp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: looks up /etc/group by GID, returns thread-local static storage",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getgrgid_r",
      "status": "Implemented",
      "module": "grp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: reentrant getgrgid into caller buffer, ERANGE on insufficient space",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getgrnam",
      "status": "Implemented",
      "module": "grp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: looks up /etc/group by name, returns thread-local static storage",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getgrnam_r",
      "status": "Implemented",
      "module": "grp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: reentrant getgrnam into caller buffer, ERANGE on insufficient space",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getgroups",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_getgroups; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates size parameter",
      "default_stub": false
    },
    {
      "symbol": "gethostname",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "getitimer",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "getnameinfo",
      "status": "Implemented",
      "module": "resolv_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Bootstrap resolver implementation: numeric getaddrinfo/getnameinfo + gai_strerror/freeaddrinfo with deterministic EAI_* failures",
      "hardened_semantics": "Resolver with deterministic repairs: invalid host/service normalized to safe defaults, evidence emitted",
      "default_stub": false
    },
    {
      "symbol": "getpeername",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "getpgid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_getpgid; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates pid parameter",
      "default_stub": false
    },
    {
      "symbol": "getpid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "getppid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "getpwent",
      "status": "Implemented",
      "module": "pwd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: iterates /etc/passwd entries sequentially",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getpwnam",
      "status": "Implemented",
      "module": "pwd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: looks up /etc/passwd by username, returns thread-local static storage",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getpwnam_r",
      "status": "Implemented",
      "module": "pwd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: reentrant getpwnam into caller buffer, ERANGE on insufficient space",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getpwuid",
      "status": "Implemented",
      "module": "pwd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: looks up /etc/passwd by UID, returns thread-local static storage",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getpwuid_r",
      "status": "Implemented",
      "module": "pwd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: reentrant getpwuid into caller buffer, ERANGE on insufficient space",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getrlimit",
      "status": "RawSyscall",
      "module": "resource_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for getrlimit/setrlimit; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies invalid resource constants",
      "default_stub": false
    },
    {
      "symbol": "getrusage",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "getsid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_getsid; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates pid parameter",
      "default_stub": false
    },
    {
      "symbol": "getsockname",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "getsockopt",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "gettimeofday",
      "status": "RawSyscall",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall via clock_gettime(CLOCK_REALTIME); POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates tv pointer",
      "default_stub": false
    },
    {
      "symbol": "getuid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "gmtime_r",
      "status": "Implemented",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure Rust epoch_to_broken_down conversion to UTC; no syscall",
      "hardened_semantics": "Pure Rust conversion with null pointer guard",
      "default_stub": false
    },
    {
      "symbol": "htonl",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure-computation byte-order and address conversion; no syscalls",
      "hardened_semantics": "Pure computation; no mode difference",
      "default_stub": false
    },
    {
      "symbol": "htons",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure-computation byte-order and address conversion; no syscalls",
      "hardened_semantics": "Pure computation; no mode difference",
      "default_stub": false
    },
    {
      "symbol": "hypot",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; finite overflow to infinity sets errno=ERANGE while preserving IEEE 754 behavior",
      "hardened_semantics": "Same ERANGE overflow signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "iconv",
      "status": "Implemented",
      "module": "iconv_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Phase-1 iconv implementation for UTF-8/ISO-8859-1/UTF-16LE/UTF-32 with deterministic errno semantics",
      "hardened_semantics": "Phase-1 iconv with hardened membrane routing; deterministic bounds/error behavior",
      "default_stub": false
    },
    {
      "symbol": "iconv_close",
      "status": "Implemented",
      "module": "iconv_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Phase-1 iconv implementation for UTF-8/ISO-8859-1/UTF-16LE/UTF-32 with deterministic errno semantics",
      "hardened_semantics": "Phase-1 iconv with hardened membrane routing; deterministic bounds/error behavior",
      "default_stub": false
    },
    {
      "symbol": "iconv_open",
      "status": "Implemented",
      "module": "iconv_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Phase-1 iconv implementation for UTF-8/ISO-8859-1/UTF-16LE/UTF-32 with deterministic errno semantics",
      "hardened_semantics": "Phase-1 iconv with hardened membrane routing; deterministic bounds/error behavior",
      "default_stub": false
    },
    {
      "symbol": "ilogb",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "index",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Alias for strchr",
      "hardened_semantics": "Same as strchr hardened semantics",
      "default_stub": false
    },
    {
      "symbol": "inet_addr",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure-computation byte-order and address conversion; no syscalls",
      "hardened_semantics": "Pure computation; no mode difference",
      "default_stub": false
    },
    {
      "symbol": "inet_aton",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Parse dotted-quad IPv4 text to in_addr; returns 1 on success, 0 on failure",
      "hardened_semantics": "Same as strict; pure compute with no mode difference",
      "default_stub": false
    },
    {
      "symbol": "inet_ntoa",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Convert IPv4 in_addr to dotted-quad string in thread-local buffer; not reentrant",
      "hardened_semantics": "Same as strict; pure compute with no mode difference",
      "default_stub": false
    },
    {
      "symbol": "inet_ntop",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure-computation byte-order and address conversion; no syscalls",
      "hardened_semantics": "Pure computation; no mode difference",
      "default_stub": false
    },
    {
      "symbol": "inet_pton",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure-computation byte-order and address conversion; no syscalls",
      "hardened_semantics": "Pure computation; no mode difference",
      "default_stub": false
    },
    {
      "symbol": "inotify_add_watch",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "inotify_init",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "inotify_init1",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "inotify_rm_watch",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "ioctl",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "isalnum",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "isalpha",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "isascii",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "trivial",
      "strict_semantics": "pass-through",
      "hardened_semantics": "pass-through",
      "default_stub": false
    },
    {
      "symbol": "isatty",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "isblank",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "trivial",
      "strict_semantics": "pass-through",
      "hardened_semantics": "pass-through",
      "default_stub": false
    },
    {
      "symbol": "iscntrl",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "trivial",
      "strict_semantics": "pass-through",
      "hardened_semantics": "pass-through",
      "default_stub": false
    },
    {
      "symbol": "isdigit",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "isgraph",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "trivial",
      "strict_semantics": "pass-through",
      "hardened_semantics": "pass-through",
      "default_stub": false
    },
    {
      "symbol": "islower",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "isprint",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "ispunct",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "isspace",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "isupper",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "isxdigit",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "kill",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for signal handling; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies invalid signal numbers instead of passing to kernel",
      "default_stub": false
    },
    {
      "symbol": "killpg",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall via kill(-pgrp, sig); POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates pgrp non-negative and signal number before passing to kernel",
      "default_stub": false
    },
    {
      "symbol": "labs",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Long absolute value via wrapping_abs",
      "hardened_semantics": "No mode difference; pure computation",
      "default_stub": false
    },
    {
      "symbol": "lchown",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "ldexp",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "ldiv",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Long division returning quotient and remainder; zero-denom returns zero",
      "hardened_semantics": "No mode difference; pure computation",
      "default_stub": false
    },
    {
      "symbol": "lgamma",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; poles at zero/negative integers and overflow regimes set errno=ERANGE",
      "hardened_semantics": "Same ERANGE signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "link",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "linkat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "listen",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "llabs",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Long long absolute value via wrapping_abs",
      "hardened_semantics": "No mode difference; pure computation",
      "default_stub": false
    },
    {
      "symbol": "lldiv",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Long long division returning quotient and remainder; zero-denom returns zero",
      "hardened_semantics": "No mode difference; pure computation",
      "default_stub": false
    },
    {
      "symbol": "llrint",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "llround",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "localeconv",
      "status": "Implemented",
      "module": "locale_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Bootstrap locale implementation: setlocale supports C/POSIX and localeconv returns static C locale struct",
      "hardened_semantics": "Locale implementation with hardened fallback to C locale defaults on invalid input",
      "default_stub": false
    },
    {
      "symbol": "localtime_r",
      "status": "RawSyscall",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for time queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; defaults invalid clock_id to CLOCK_REALTIME",
      "default_stub": false
    },
    {
      "symbol": "log",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; x<0 sets errno=EDOM and x==0 sets errno=ERANGE with IEEE 754 outputs preserved",
      "hardened_semantics": "Same errno domain/range signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "log10",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; x<0 sets errno=EDOM and x==0 sets errno=ERANGE with IEEE 754 outputs preserved",
      "hardened_semantics": "Same errno domain/range signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "log10f",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "log1p",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; x<-1 sets errno=EDOM and x==-1 sets errno=ERANGE with IEEE 754 outputs preserved",
      "hardened_semantics": "Same errno domain/range signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "log2",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; x<0 sets errno=EDOM and x==0 sets errno=ERANGE with IEEE 754 outputs preserved",
      "hardened_semantics": "Same errno domain/range signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "log2f",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "logb",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "logf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "lrint",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "lround",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "lseek",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "lstat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "madvise",
      "status": "RawSyscall",
      "module": "mmap_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for virtual memory; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies conflicting prot/flags combinations",
      "default_stub": false
    },
    {
      "symbol": "malloc",
      "status": "Implemented",
      "module": "malloc_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust arena allocator; null on failure; double-free silently ignored",
      "hardened_semantics": "Arena with healing: foreign-ptr realloc as malloc, double-free logged as HealingAction",
      "default_stub": false
    },
    {
      "symbol": "memalign",
      "status": "Implemented",
      "module": "malloc_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust arena allocator; null on failure; double-free silently ignored",
      "hardened_semantics": "Arena with healing: foreign-ptr realloc as malloc, double-free logged as HealingAction",
      "default_stub": false
    },
    {
      "symbol": "memccpy",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust byte copy until stop character; no repair",
      "hardened_semantics": "Clamps copy length to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "memchr",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "memcmp",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "memcpy",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "memmem",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust subsequence search via sliding window; no repair",
      "hardened_semantics": "Clamps haystack/needle to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "memmove",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "mempcpy",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust memcpy variant returning pointer past last written byte; no repair",
      "hardened_semantics": "Clamps copy to tracked allocation bounds; returns clamped end pointer",
      "default_stub": false
    },
    {
      "symbol": "memrchr",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "memset",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "mkdir",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "mkdirat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "mkfifo",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "mknod",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "mktime",
      "status": "Implemented",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure Rust broken_down_to_epoch with field normalization; UTC only",
      "hardened_semantics": "Pure Rust conversion; normalizes fields, UTC only",
      "default_stub": false
    },
    {
      "symbol": "mlock",
      "status": "RawSyscall",
      "module": "mmap_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "mlockall",
      "status": "RawSyscall",
      "module": "mmap_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "mmap",
      "status": "RawSyscall",
      "module": "mmap_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for virtual memory; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies conflicting prot/flags combinations",
      "default_stub": false
    },
    {
      "symbol": "modf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "mprotect",
      "status": "RawSyscall",
      "module": "mmap_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for virtual memory; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies conflicting prot/flags combinations",
      "default_stub": false
    },
    {
      "symbol": "msync",
      "status": "RawSyscall",
      "module": "mmap_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for virtual memory; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies conflicting prot/flags combinations",
      "default_stub": false
    },
    {
      "symbol": "munlock",
      "status": "RawSyscall",
      "module": "mmap_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "munlockall",
      "status": "RawSyscall",
      "module": "mmap_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "munmap",
      "status": "RawSyscall",
      "module": "mmap_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for virtual memory; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies conflicting prot/flags combinations",
      "default_stub": false
    },
    {
      "symbol": "nanosleep",
      "status": "RawSyscall",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_nanosleep; sets errno EINTR on signal interruption",
      "hardened_semantics": "Raw syscall; validates req pointer",
      "default_stub": false
    },
    {
      "symbol": "nearbyint",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "nextafter",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "ntohl",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure-computation byte-order and address conversion; no syscalls",
      "hardened_semantics": "Pure computation; no mode difference",
      "default_stub": false
    },
    {
      "symbol": "ntohs",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure-computation byte-order and address conversion; no syscalls",
      "hardened_semantics": "Pure computation; no mode difference",
      "default_stub": false
    },
    {
      "symbol": "open",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "openat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "opendir",
      "status": "RawSyscall",
      "module": "dirent_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for directory enumeration; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates path pointer bounds before getdents64",
      "default_stub": false
    },
    {
      "symbol": "pause",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_pause; always returns -1 with EINTR",
      "hardened_semantics": "Raw syscall; membrane-gated suspension with EINTR on signal delivery",
      "default_stub": false
    },
    {
      "symbol": "perror",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native errno-to-message mapping with direct write to stderr fd; no host glibc delegation",
      "hardened_semantics": "Native implementation; membrane validates optional prefix string, logs TruncateWithNull for unterminated strings",
      "default_stub": false
    },
    {
      "symbol": "pipe",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for dup/dup2/pipe/fcntl; POSIX errno on failure",
      "hardened_semantics": "Raw syscall with hardened membrane; repair on invalid flags",
      "default_stub": false
    },
    {
      "symbol": "pipe2",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "poll",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for I/O multiplexing; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps nfds to tracked pollfd array bounds",
      "default_stub": false
    },
    {
      "symbol": "posix_memalign",
      "status": "Implemented",
      "module": "malloc_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust arena allocator; null on failure; double-free silently ignored",
      "hardened_semantics": "Arena with healing: foreign-ptr realloc as malloc, double-free logged as HealingAction",
      "default_stub": false
    },
    {
      "symbol": "pow",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; 0^negative and finite overflow/underflow set errno=ERANGE, negative base with fractional exponent sets errno=EDOM",
      "hardened_semantics": "Same errno signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "powf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "ppoll",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for I/O multiplexing; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps nfds to tracked pollfd array bounds",
      "default_stub": false
    },
    {
      "symbol": "prctl",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "pread",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "printf",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native printf engine writing directly to stdout via syscall-backed path; no host glibc call-through",
      "hardened_semantics": "Native printf engine + membrane validation/repair on stdout path; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "pselect",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for I/O multiplexing; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps nfds to tracked pollfd array bounds",
      "default_stub": false
    },
    {
      "symbol": "pthread_cond_broadcast",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native futex-backed condvar implementation; requires managed mutex association and returns deterministic errno on invalid state",
      "hardened_semantics": "Native futex-backed condvar with deterministic validation of cond/mutex association and bounded wake behavior",
      "default_stub": false
    },
    {
      "symbol": "pthread_cond_destroy",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native condvar destroy returns EBUSY when waiters are present and clears association on success",
      "hardened_semantics": "Native condvar destroy enforces waiter-count invariants with deterministic EBUSY/EINVAL outcomes",
      "default_stub": false
    },
    {
      "symbol": "pthread_cond_init",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native condvar initialization with deterministic default clock and null/attr validation contract",
      "hardened_semantics": "Native condvar initialization with deterministic pointer validation and explicit unsupported-attribute rejection",
      "default_stub": false
    },
    {
      "symbol": "pthread_cond_signal",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native futex-backed condvar signal increments sequence and wakes one waiter when present",
      "hardened_semantics": "Native futex-backed condvar signal with deterministic wake policy and invariant-preserving sequence updates",
      "default_stub": false
    },
    {
      "symbol": "pthread_cond_wait",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native condvar wait with futex choreography; requires managed mutex and enforces association invariants",
      "hardened_semantics": "Native condvar wait with deterministic validation, bounded wake/relock path, and explicit EINVAL on invalid association",
      "default_stub": false
    },
    {
      "symbol": "pthread_create",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native clone-backed thread creation via core ThreadHandle; null thread_out/start rejected with EINVAL and non-null attr rejected deterministically",
      "hardened_semantics": "Native clone-backed thread creation with membrane policy gating and deterministic handle-registry ownership checks",
      "default_stub": false
    },
    {
      "symbol": "pthread_detach",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native detach on managed ThreadHandle registry; unknown or already-consumed thread ids return deterministic ESRCH",
      "hardened_semantics": "Native detach with membrane policy gating and deterministic registry ownership enforcement",
      "default_stub": false
    },
    {
      "symbol": "pthread_equal",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native pthread_t identity comparison (reflexive equality over managed handle ids and fallback tid ids)",
      "hardened_semantics": "Native identity comparison under membrane policy routing with deterministic 0/1 return",
      "default_stub": false
    },
    {
      "symbol": "pthread_join",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native join on managed ThreadHandle registry with deterministic ESRCH for unknown ids and core join errno propagation",
      "hardened_semantics": "Native join with membrane policy gating and deterministic registry ownership enforcement",
      "default_stub": false
    },
    {
      "symbol": "pthread_mutex_destroy",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Futex-managed NORMAL mutex core; supports init(NULL attr) and lazy promotion for zero-initialized default mutexes; unsupported attributed/foreign layouts return deterministic EINVAL",
      "hardened_semantics": "Same futex-managed core with deterministic spin/wait/wake telemetry and identical errno contract",
      "default_stub": false
    },
    {
      "symbol": "pthread_mutex_init",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Futex-managed NORMAL mutex core; supports init(NULL attr) and lazy promotion for zero-initialized default mutexes; unsupported attributed/foreign layouts return deterministic EINVAL",
      "hardened_semantics": "Same futex-managed core with deterministic spin/wait/wake telemetry and identical errno contract",
      "default_stub": false
    },
    {
      "symbol": "pthread_mutex_lock",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Futex-managed NORMAL mutex core; supports init(NULL attr) and lazy promotion for zero-initialized default mutexes; unsupported attributed/foreign layouts return deterministic EINVAL",
      "hardened_semantics": "Same futex-managed core with deterministic spin/wait/wake telemetry and identical errno contract",
      "default_stub": false
    },
    {
      "symbol": "pthread_mutex_trylock",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Futex-managed NORMAL mutex core; supports init(NULL attr) and lazy promotion for zero-initialized default mutexes; unsupported attributed/foreign layouts return deterministic EINVAL",
      "hardened_semantics": "Same futex-managed core with deterministic spin/wait/wake telemetry and identical errno contract",
      "default_stub": false
    },
    {
      "symbol": "pthread_mutex_unlock",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Futex-managed NORMAL mutex core; supports init(NULL attr) and lazy promotion for zero-initialized default mutexes; unsupported attributed/foreign layouts return deterministic EINVAL",
      "hardened_semantics": "Same futex-managed core with deterministic spin/wait/wake telemetry and identical errno contract",
      "default_stub": false
    },
    {
      "symbol": "pthread_rwlock_destroy",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native futex-backed rwlock destroy; returns EBUSY when reader/writer state is active and EINVAL for unmanaged storage",
      "hardened_semantics": "Native futex-backed rwlock destroy with deterministic managed-state validation and explicit busy-state rejection",
      "default_stub": false
    },
    {
      "symbol": "pthread_rwlock_init",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native futex-backed rwlock init with deterministic managed magic tagging and null-attr requirement",
      "hardened_semantics": "Native futex-backed rwlock init with deterministic pointer validation and explicit unsupported-attribute rejection",
      "default_stub": false
    },
    {
      "symbol": "pthread_rwlock_rdlock",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native futex-backed read lock with reader-count state machine and deterministic EINVAL for unmanaged storage",
      "hardened_semantics": "Native futex-backed read lock with deterministic state validation and bounded wait behavior",
      "default_stub": false
    },
    {
      "symbol": "pthread_rwlock_unlock",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native futex-backed unlock for writer/reader holders; deterministic EPERM for unlocked state and EINVAL for unmanaged storage",
      "hardened_semantics": "Native futex-backed unlock with deterministic holder-state checks and wake-on-last-release behavior",
      "default_stub": false
    },
    {
      "symbol": "pthread_rwlock_wrlock",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native futex-backed write lock with exclusive writer state and deterministic EINVAL for unmanaged storage",
      "hardened_semantics": "Native futex-backed write lock with deterministic state validation and bounded wait behavior",
      "default_stub": false
    },
    {
      "symbol": "pthread_self",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native self id resolution: returns managed ThreadHandle-backed pthread_t when available, otherwise kernel tid fallback",
      "hardened_semantics": "Native self id resolution under membrane policy routing with deterministic managed-handle preference",
      "default_stub": false
    },
    {
      "symbol": "pthread_sigmask",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to sigprocmask; identical on Linux (rt_sigprocmask)",
      "hardened_semantics": "Delegates to sigprocmask with membrane gating",
      "default_stub": false
    },
    {
      "symbol": "putchar",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "puts",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native string scan with direct write to stdout fd plus trailing newline; no host glibc delegation",
      "hardened_semantics": "Native implementation; membrane bounds string scan, logs TruncateWithNull for unterminated strings",
      "default_stub": false
    },
    {
      "symbol": "pwrite",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "qsort",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "raise",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for signal handling; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies invalid signal numbers instead of passing to kernel",
      "default_stub": false
    },
    {
      "symbol": "rand",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Thread-local LCG pseudo-random generator; glibc-compatible constants",
      "hardened_semantics": "No mode difference; pure computation",
      "default_stub": false
    },
    {
      "symbol": "rand_r",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Reentrant LCG pseudo-random generator using caller-provided state",
      "hardened_semantics": "Null seedp check; returns 0 on null",
      "default_stub": false
    },
    {
      "symbol": "read",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "readdir",
      "status": "RawSyscall",
      "module": "dirent_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for directory enumeration; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates path pointer bounds before getdents64",
      "default_stub": false
    },
    {
      "symbol": "readlink",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "readlinkat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "readv",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "realloc",
      "status": "Implemented",
      "module": "malloc_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust arena allocator; null on failure; double-free silently ignored",
      "hardened_semantics": "Arena with healing: foreign-ptr realloc as malloc, double-free logged as HealingAction",
      "default_stub": false
    },
    {
      "symbol": "recv",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "recvfrom",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "recvmsg",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for scatter/gather receive via msghdr; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates msghdr pointer",
      "default_stub": false
    },
    {
      "symbol": "remainder",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; y==0 or infinite x with finite y sets errno=EDOM while preserving IEEE 754 NaN behavior",
      "hardened_semantics": "Same errno signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "rename",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "renameat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "rewind",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "rindex",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Alias for strrchr",
      "hardened_semantics": "Same as strrchr hardened semantics",
      "default_stub": false
    },
    {
      "symbol": "rint",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; rounds according to current floating-point mode while preserving IEEE 754 NaN/Inf behavior",
      "hardened_semantics": "Rust libm path; no mode difference expected for finite inputs",
      "default_stub": false
    },
    {
      "symbol": "rmdir",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "round",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "roundf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "scalbln",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "scalbn",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "sched_yield",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "secure_getenv",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "select",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for I/O multiplexing; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps nfds to tracked pollfd array bounds",
      "default_stub": false
    },
    {
      "symbol": "send",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "sendfile",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "sendmsg",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for scatter/gather send via msghdr; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates msghdr pointer",
      "default_stub": false
    },
    {
      "symbol": "sendto",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "setbuf",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "setegid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall via SYS_setregid; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; credential change operation",
      "default_stub": false
    },
    {
      "symbol": "setenv",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "seteuid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall via SYS_setreuid; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; credential change operation",
      "default_stub": false
    },
    {
      "symbol": "setgid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_setgid; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; credential change operation",
      "default_stub": false
    },
    {
      "symbol": "setgrent",
      "status": "Implemented",
      "module": "grp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: rewinds /etc/group iteration cursor",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "setgroups",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_setgroups; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; credential change operation",
      "default_stub": false
    },
    {
      "symbol": "setitimer",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "setlocale",
      "status": "Implemented",
      "module": "locale_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Bootstrap locale implementation: setlocale supports C/POSIX and localeconv returns static C locale struct",
      "hardened_semantics": "Locale implementation with hardened fallback to C locale defaults on invalid input",
      "default_stub": false
    },
    {
      "symbol": "setpgid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_setpgid; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates pid and pgid parameters",
      "default_stub": false
    },
    {
      "symbol": "setpwent",
      "status": "Implemented",
      "module": "pwd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: rewinds /etc/passwd iteration cursor",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "setregid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_setregid; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; credential change operation",
      "default_stub": false
    },
    {
      "symbol": "setreuid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_setreuid; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; credential change operation",
      "default_stub": false
    },
    {
      "symbol": "setrlimit",
      "status": "RawSyscall",
      "module": "resource_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for getrlimit/setrlimit; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies invalid resource constants",
      "default_stub": false
    },
    {
      "symbol": "setsid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_setsid; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; session creation",
      "default_stub": false
    },
    {
      "symbol": "setsockopt",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "setuid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_setuid; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; credential change operation",
      "default_stub": false
    },
    {
      "symbol": "setvbuf",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "shutdown",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "sigaction",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for signal handling; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies invalid signal numbers instead of passing to kernel",
      "default_stub": false
    },
    {
      "symbol": "sigaddset",
      "status": "Implemented",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure bit manipulation on sigset_t; validates signal number, sets errno EINVAL on failure",
      "hardened_semantics": "Pure bit manipulation; validates signal number range before modification",
      "default_stub": false
    },
    {
      "symbol": "sigaltstack",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_sigaltstack; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; membrane-gated alternate signal stack management",
      "default_stub": false
    },
    {
      "symbol": "sigdelset",
      "status": "Implemented",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure bit manipulation on sigset_t; validates signal number, sets errno EINVAL on failure",
      "hardened_semantics": "Pure bit manipulation; validates signal number range before modification",
      "default_stub": false
    },
    {
      "symbol": "sigemptyset",
      "status": "Implemented",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Zeroes entire sigset_t structure; null pointer returns -1",
      "hardened_semantics": "Zeroes sigset_t; null pointer guard returns -1",
      "default_stub": false
    },
    {
      "symbol": "sigfillset",
      "status": "Implemented",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Sets all bits in sigset_t structure; null pointer returns -1",
      "hardened_semantics": "Sets all sigset_t bits; null pointer guard returns -1",
      "default_stub": false
    },
    {
      "symbol": "sigismember",
      "status": "Implemented",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure bit query on sigset_t; returns 1 if signal in set, 0 if not, -1 on invalid input",
      "hardened_semantics": "Pure bit query; validates signal number range before testing membership",
      "default_stub": false
    },
    {
      "symbol": "signal",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for signal handling; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies invalid signal numbers instead of passing to kernel",
      "default_stub": false
    },
    {
      "symbol": "sigprocmask",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_rt_sigprocmask; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; membrane-gated signal mask manipulation",
      "default_stub": false
    },
    {
      "symbol": "sigsuspend",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_rt_sigsuspend; always returns -1 with EINTR",
      "hardened_semantics": "Raw syscall; membrane-gated signal suspension with EINTR on delivery",
      "default_stub": false
    },
    {
      "symbol": "sin",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "sinf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "sinh",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; finite overflow to signed infinity sets errno=ERANGE while preserving IEEE 754 behavior",
      "hardened_semantics": "Same ERANGE overflow signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "sleep",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "snprintf",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native printf engine into caller-provided bounded buffer; no host glibc call-through",
      "hardened_semantics": "Native bounded formatting path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "socket",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "socketpair",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall to create a pair of connected sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates sv output pointer and address family/type arguments",
      "default_stub": false
    },
    {
      "symbol": "sprintf",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native printf engine into caller-provided buffer; no host glibc call-through",
      "hardened_semantics": "Native unbounded formatting path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "sqrt",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; finite x<0 sets errno=EDOM and preserves signed zero plus IEEE 754 NaN/Inf behavior",
      "hardened_semantics": "Same domain errno signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "sqrtf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "srand",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Seeds thread-local LCG generator",
      "hardened_semantics": "No mode difference; pure computation",
      "default_stub": false
    },
    {
      "symbol": "stat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "stderr",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "stdin",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "stdout",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "stpcpy",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "stpncpy",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strcasecmp",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust case-insensitive compare; ASCII lowering; unbounded scan; no repair",
      "hardened_semantics": "Clamps scan to tracked allocation bounds; logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strcasestr",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust case-insensitive substring search via eq_ignore_ascii_case; no repair",
      "hardened_semantics": "Clamps scan to tracked allocation bounds; logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strcat",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strchr",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strchrnul",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strcmp",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strcoll",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Delegates to strcmp in C/POSIX locale; no repair",
      "hardened_semantics": "Scans within tracked bounds; same as strcmp hardened",
      "default_stub": false
    },
    {
      "symbol": "strcpy",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strcspn",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust complement span scan; returns length of initial segment not in reject set",
      "hardened_semantics": "Clamps scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strdup",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string scan + malloc + copy; no repair; returns malloc'd duplicate",
      "hardened_semantics": "Clamps scan to tracked allocation bounds; malloc via membrane allocator",
      "default_stub": false
    },
    {
      "symbol": "strerror",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native errno-to-message mapping; returns thread-local static buffer; no host glibc",
      "hardened_semantics": "Same as strict; thread-local buffer prevents data races",
      "default_stub": false
    },
    {
      "symbol": "strerror_r",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "coldpath",
      "strict_semantics": "XSI-compliant reentrant strerror; copies message into caller buffer; returns 0 or ERANGE",
      "hardened_semantics": "Same as strict; bounded write into caller buffer",
      "default_stub": false
    },
    {
      "symbol": "strlcat",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust bounded concatenation with guaranteed NUL termination; no repair",
      "hardened_semantics": "Clamps to tracked allocation bounds; logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strlcpy",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust bounded copy with guaranteed NUL termination; no repair",
      "hardened_semantics": "Clamps to tracked allocation bounds; logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strlen",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strncat",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strncasecmp",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust case-insensitive compare of at most n bytes; ASCII lowering; no repair",
      "hardened_semantics": "Clamps compare span to tracked allocation bounds; logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strncmp",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strncpy",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strndup",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; scans up to n bytes then malloc+copy; no repair",
      "hardened_semantics": "Clamps scan to tracked allocation bounds; malloc via membrane allocator",
      "default_stub": false
    },
    {
      "symbol": "strnlen",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strpbrk",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strrchr",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strsep",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust token extraction with NUL delimiter write; no repair",
      "hardened_semantics": "Scans within tracked bounds; clamps string pointer updates",
      "default_stub": false
    },
    {
      "symbol": "strspn",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strstr",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strtod",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "String-to-double with endptr via Rust parse; supports inf/nan/hex",
      "hardened_semantics": "Membrane-validated string scan before parse",
      "default_stub": false
    },
    {
      "symbol": "strtof",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "String-to-float via strtod with narrowing cast",
      "hardened_semantics": "Same as strtod hardened semantics",
      "default_stub": false
    },
    {
      "symbol": "strtoimax",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "strtok",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strtok_r",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strtol",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "strtoll",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "strtoul",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "strtoull",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "strtoumax",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "strxfrm",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Plain copy in C/POSIX locale; no repair",
      "hardened_semantics": "Clamps to tracked allocation bounds",
      "default_stub": false
    },
    {
      "symbol": "swab",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust adjacent byte pair swap; no repair",
      "hardened_semantics": "Clamps length to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "symlink",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "symlinkat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "sysconf",
      "status": "Implemented",
      "module": "unistd_abi",
      "perf_class": "native",
      "semantics": "POSIX"
    },
    {
      "symbol": "tan",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "tanf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "tanh",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; bounded odd hyperbolic tangent over finite domain; no errno side effects",
      "hardened_semantics": "Rust std::f64 math; no mode difference expected for finite inputs",
      "default_stub": false
    },
    {
      "symbol": "tcdrain",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "tcflow",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "tcflush",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "tcgetattr",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "tcsendbreak",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "tcsetattr",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "tgamma",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; negative integer poles set errno=EDOM, zero/pole-overflow/underflow regimes set errno=ERANGE",
      "hardened_semantics": "Same errno signaling with runtime-policy routing; hardened mode may repair non-finite outputs deterministically",
      "default_stub": false
    },
    {
      "symbol": "time",
      "status": "RawSyscall",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for time queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; defaults invalid clock_id to CLOCK_REALTIME",
      "default_stub": false
    },
    {
      "symbol": "timegm",
      "status": "Implemented",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to mktime; pure Rust broken_down_to_epoch; UTC",
      "hardened_semantics": "Delegates to mktime with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "timerfd_create",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "timerfd_gettime",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "timerfd_settime",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "syscall_veneer",
      "semantics": "Linux"
    },
    {
      "symbol": "toascii",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "trivial",
      "strict_semantics": "pass-through",
      "hardened_semantics": "pass-through",
      "default_stub": false
    },
    {
      "symbol": "tolower",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "toupper",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "trunc",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust libm path; rounds toward zero while preserving IEEE 754 NaN/Inf behavior",
      "hardened_semantics": "Rust libm path; no mode difference expected for finite inputs",
      "default_stub": false
    },
    {
      "symbol": "truncate",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "truncf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "heal-non-finite",
      "default_stub": false
    },
    {
      "symbol": "umask",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "uname",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "ungetc",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "unlink",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "unlinkat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "unsetenv",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "usleep",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "vfork",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to fork; identical on modern Linux",
      "hardened_semantics": "Delegates to fork with membrane gating",
      "default_stub": false
    },
    {
      "symbol": "wait",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for process control; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates argv/envp pointer arrays before execve",
      "default_stub": false
    },
    {
      "symbol": "wait3",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to wait4(-1, ...); BSD-style wait with rusage",
      "hardened_semantics": "Delegates to wait4 with membrane gating",
      "default_stub": false
    },
    {
      "symbol": "wait4",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_wait4; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates options in hardened mode",
      "default_stub": false
    },
    {
      "symbol": "waitid",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall SYS_waitid; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates idtype and options",
      "default_stub": false
    },
    {
      "symbol": "waitpid",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for process control; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates argv/envp pointer arrays before execve",
      "default_stub": false
    },
    {
      "symbol": "wcscat",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcschr",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcscmp",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcscpy",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcscspn",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "bounds-check-and-repair",
      "default_stub": false
    },
    {
      "symbol": "wcsdup",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "bounds-check-and-repair",
      "default_stub": false
    },
    {
      "symbol": "wcslen",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcsncat",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "bounds-check-and-repair",
      "default_stub": false
    },
    {
      "symbol": "wcsncmp",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcsncpy",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcspbrk",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "bounds-check-and-repair",
      "default_stub": false
    },
    {
      "symbol": "wcsrchr",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcsspn",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "bounds-check-and-repair",
      "default_stub": false
    },
    {
      "symbol": "wcsstr",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcstok",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "hotpath",
      "strict_semantics": "pass-through",
      "hardened_semantics": "bounds-check-and-repair",
      "default_stub": false
    },
    {
      "symbol": "wmemchr",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wmemcmp",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wmemcpy",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wmemmove",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wmemset",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "write",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "writev",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "syscall_veneer",
      "semantics": "POSIX"
    },
    {
      "symbol": "getc",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Function alias for fgetc; reads one byte from stream",
      "hardened_semantics": "Same as strict; inherits fgetc membrane checks",
      "default_stub": false
    },
    {
      "symbol": "putc",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Function alias for fputc; writes one byte to stream",
      "hardened_semantics": "Same as strict; inherits fputc membrane checks",
      "default_stub": false
    },
    {
      "symbol": "fgetpos",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "strict_fast",
      "strict_semantics": "Store current stream position into fpos_t",
      "hardened_semantics": "Same as strict with null-pointer validation",
      "default_stub": false
    },
    {
      "symbol": "fsetpos",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "strict_fast",
      "strict_semantics": "Restore stream position from fpos_t (delegates to fseek)",
      "hardened_semantics": "Same as strict with null-pointer validation",
      "default_stub": false
    },
    {
      "symbol": "fdopen",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "strict_fast",
      "strict_semantics": "Associate a FILE stream with an existing fd; mode validation",
      "hardened_semantics": "Same as strict; invalid mode returns NULL",
      "default_stub": false
    },
    {
      "symbol": "freopen",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "strict_slow",
      "strict_semantics": "Close stream and reopen with new file/mode",
      "hardened_semantics": "Same as strict; flushes pending writes before close",
      "default_stub": false
    },
    {
      "symbol": "remove",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "strict_slow",
      "strict_semantics": "Remove file via unlinkat; falls back to rmdir for directories",
      "hardened_semantics": "Same as strict with null-pointer guard",
      "default_stub": false
    },
    {
      "symbol": "getdelim",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "strict_slow",
      "strict_semantics": "Read until delimiter with dynamic buffer allocation via malloc",
      "hardened_semantics": "Same as strict; validates all pointer arguments",
      "default_stub": false
    },
    {
      "symbol": "getline",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "strict_slow",
      "strict_semantics": "Read line (newline-delimited); delegates to getdelim",
      "hardened_semantics": "Same as strict; validates all pointer arguments",
      "default_stub": false
    },
    {
      "symbol": "tmpfile",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "strict_slow",
      "strict_semantics": "Create temporary file via O_TMPFILE with fallback to mkstemp+unlink",
      "hardened_semantics": "Same as strict; auto-deleted on close",
      "default_stub": false
    },
    {
      "symbol": "tmpnam",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "strict_fast",
      "strict_semantics": "Generate unique temp filename using pid+counter",
      "hardened_semantics": "Same as strict; thread-safe with atomic counter",
      "default_stub": false
    },
    {
      "symbol": "acoshf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "asinhf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "atanhf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "cbrtf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "copysignf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "coshf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "erfcf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "erff",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "exp2f",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "expm1f",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "fdimf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "fmaf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "fmaxf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "fminf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "frexpf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "hypotf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "ilogbf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "ldexpf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "lgammaf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "llrintf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "llroundf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "log1pf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "logbf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "lrintf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "lroundf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "modff",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "nearbyintf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "nextafterf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "remainderf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "rintf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "scalblnf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "scalbnf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "sinhf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "tanhf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "tgammaf",
      "header": "math.h",
      "status": "Implemented",
      "module": "math_abi",
      "notes": ""
    },
    {
      "symbol": "nl_langinfo",
      "header": "langinfo.h",
      "status": "GlibcCallThrough",
      "module": "locale_abi",
      "notes": ""
    },
    {
      "symbol": "system",
      "header": "stdlib.h",
      "status": "Implemented",
      "module": "stdlib_abi",
      "notes": ""
    },
    {
      "symbol": "putenv",
      "header": "stdlib.h",
      "status": "Implemented",
      "module": "stdlib_abi",
      "notes": ""
    },
    {
      "symbol": "popen",
      "header": "stdio.h",
      "status": "Implemented",
      "module": "stdio_abi",
      "notes": ""
    },
    {
      "symbol": "pclose",
      "header": "stdio.h",
      "status": "Implemented",
      "module": "stdio_abi",
      "notes": ""
    },
    {
      "symbol": "strftime",
      "header": "time.h",
      "family": "time",
      "status": "Implemented",
      "notes": "Full POSIX strftime format specifier support (UTC only)"
    },
    {
      "symbol": "mblen",
      "header": "stdlib.h",
      "family": "wchar",
      "status": "Implemented",
      "notes": "UTF-8 multibyte character length"
    },
    {
      "symbol": "mbtowc",
      "header": "stdlib.h",
      "family": "wchar",
      "status": "Implemented",
      "notes": "UTF-8 multibyte to wide character"
    },
    {
      "symbol": "wctomb",
      "header": "stdlib.h",
      "family": "wchar",
      "status": "Implemented",
      "notes": "Wide character to UTF-8 multibyte"
    },
    {
      "symbol": "mbstowcs",
      "header": "stdlib.h",
      "family": "wchar",
      "status": "Implemented",
      "notes": "UTF-8 multibyte string to wide string"
    },
    {
      "symbol": "wcstombs",
      "header": "stdlib.h",
      "family": "wchar",
      "status": "Implemented",
      "notes": "Wide string to UTF-8 multibyte string"
    },
    {
      "symbol": "iswalnum",
      "header": "wctype.h",
      "family": "wctype",
      "status": "Implemented",
      "notes": "Wide character alphanumeric test"
    },
    {
      "symbol": "iswalpha",
      "header": "wctype.h",
      "family": "wctype",
      "status": "Implemented",
      "notes": "Wide character alphabetic test"
    },
    {
      "symbol": "iswdigit",
      "header": "wctype.h",
      "family": "wctype",
      "status": "Implemented",
      "notes": "Wide character digit test"
    },
    {
      "symbol": "iswlower",
      "header": "wctype.h",
      "family": "wctype",
      "status": "Implemented",
      "notes": "Wide character lowercase test"
    },
    {
      "symbol": "iswupper",
      "header": "wctype.h",
      "family": "wctype",
      "status": "Implemented",
      "notes": "Wide character uppercase test"
    },
    {
      "symbol": "iswspace",
      "header": "wctype.h",
      "family": "wctype",
      "status": "Implemented",
      "notes": "Wide character whitespace test"
    },
    {
      "symbol": "iswprint",
      "header": "wctype.h",
      "family": "wctype",
      "status": "Implemented",
      "notes": "Wide character printable test"
    },
    {
      "symbol": "towupper",
      "header": "wctype.h",
      "family": "wctype",
      "status": "Implemented",
      "notes": "Wide character to uppercase"
    },
    {
      "symbol": "towlower",
      "header": "wctype.h",
      "family": "wctype",
      "status": "Implemented",
      "notes": "Wide character to lowercase"
    },
    {
      "symbol": "wcwidth",
      "header": "wchar.h",
      "family": "wchar",
      "status": "Implemented",
      "notes": "Wide character display width"
    },
    {
      "symbol": "basename",
      "header": "libgen.h",
      "family": "unistd",
      "status": "Implemented",
      "notes": "Extract filename from path"
    },
    {
      "symbol": "dirname",
      "header": "libgen.h",
      "family": "unistd",
      "status": "Implemented",
      "notes": "Extract directory from path"
    },
    {
      "symbol": "realpath",
      "header": "stdlib.h",
      "family": "unistd",
      "status": "GlibcCallThrough",
      "notes": "Resolve pathname (delegates to libc)"
    },
    {
      "symbol": "mkstemp",
      "header": "stdlib.h",
      "family": "unistd",
      "status": "GlibcCallThrough",
      "notes": "Create temporary file (delegates to libc)"
    },
    {
      "symbol": "vprintf",
      "header": "stdio.h",
      "family": "stdio",
      "status": "GlibcCallThrough",
      "notes": "Delegates to libc (va_list forwarding requires C ABI)"
    },
    {
      "symbol": "vfprintf",
      "header": "stdio.h",
      "family": "stdio",
      "status": "GlibcCallThrough",
      "notes": "Delegates to libc (va_list forwarding requires C ABI)"
    },
    {
      "symbol": "vsprintf",
      "header": "stdio.h",
      "family": "stdio",
      "status": "GlibcCallThrough",
      "notes": "Delegates to libc (va_list forwarding requires C ABI)"
    },
    {
      "symbol": "vsnprintf",
      "header": "stdio.h",
      "family": "stdio",
      "status": "GlibcCallThrough",
      "notes": "Delegates to libc (va_list forwarding requires C ABI)"
    },
    {
      "symbol": "vdprintf",
      "header": "stdio.h",
      "family": "stdio",
      "status": "GlibcCallThrough",
      "notes": "Delegates to libc (va_list forwarding requires C ABI)"
    },
    {
      "symbol": "vasprintf",
      "header": "stdio.h",
      "family": "stdio",
      "status": "GlibcCallThrough",
      "notes": "Delegates to libc (va_list forwarding requires C ABI)"
    }
  ],
  "summary": {
    "total_exported": 522,
    "Implemented": 345,
    "RawSyscall": 172,
    "GlibcCallThrough": 5,
    "Stub": 0
  },
  "implemented": 363,
  "raw_syscall": 172,
  "glibc_call_through": 13,
  "stub": 0
}
